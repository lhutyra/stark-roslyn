// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using StarkPlatform.CodeAnalysis.Syntax.InternalSyntax;
using Roslyn.Utilities;


namespace StarkPlatform.CodeAnalysis.Stark.Syntax
{
  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
    public SimpleNameSyntax WithIdentifier(SyntaxToken identifier) => WithIdentifierCore(identifier);
    internal abstract SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier);
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  public sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    internal IdentifierNameSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IdentifierNameSyntax)this.Green).identifier, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIdentifierName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIdentifierName(this);
    }

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.IdentifierName(identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
    public new IdentifierNameSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier);
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  public sealed partial class QualifiedNameSyntax : NameSyntax
  {
    private NameSyntax left;
    private SimpleNameSyntax right;

    internal QualifiedNameSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left 
    {
        get
        {
            return this.GetRedAtZero(ref this.left);
        }
    }

    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.QualifiedNameSyntax)this.Green).dotToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right 
    {
        get
        {
            return this.GetRed(ref this.right, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.left);
            case 2: return this.GetRed(ref this.right, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedName(this);
    }

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            var newNode = SyntaxFactory.QualifiedName(left, dotToken, right);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QualifiedNameSyntax WithLeft(NameSyntax left)
    {
        return this.Update(left, this.DotToken, this.Right);
    }

    public QualifiedNameSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Left, dotToken, this.Right);
    }

    public QualifiedNameSyntax WithRight(SimpleNameSyntax right)
    {
        return this.Update(this.Left, this.DotToken, right);
    }
  }

  /// <summary>Class which represents the syntax node for generic name.</summary>
  public sealed partial class GenericNameSyntax : SimpleNameSyntax
  {
    private TypeArgumentListSyntax typeArgumentList;

    internal GenericNameSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.GenericNameSyntax)this.Green).identifier, this.Position, 0); }
    }

    /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
    public TypeArgumentListSyntax TypeArgumentList 
    {
        get
        {
            return this.GetRed(ref this.typeArgumentList, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.typeArgumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.typeArgumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGenericName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGenericName(this);
    }

    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
        if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
        {
            var newNode = SyntaxFactory.GenericName(identifier, typeArgumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SimpleNameSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
    public new GenericNameSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.TypeArgumentList);
    }

    public GenericNameSyntax WithTypeArgumentList(TypeArgumentListSyntax typeArgumentList)
    {
        return this.Update(this.Identifier, typeArgumentList);
    }

    public GenericNameSyntax AddTypeArgumentListArguments(params TypeSyntax[] items)
    {
        return this.WithTypeArgumentList(this.TypeArgumentList.WithArguments(this.TypeArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for type argument list.</summary>
  public sealed partial class TypeArgumentListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode arguments;

    internal TypeArgumentListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing less than.</summary>
    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeArgumentListSyntax)this.Green).lessThanToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
    public SeparatedSyntaxList<TypeSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<TypeSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<TypeSyntax>);
        }
    }

    /// <summary>SyntaxToken representing greater than.</summary>
    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeArgumentListSyntax)this.Green).greaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeArgumentList(this);
    }

    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeArgumentListSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Arguments, this.GreaterThanToken);
    }

    public TypeArgumentListSyntax WithArguments(SeparatedSyntaxList<TypeSyntax> arguments)
    {
        return this.Update(this.LessThanToken, arguments, this.GreaterThanToken);
    }

    public TypeArgumentListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Arguments, greaterThanToken);
    }

    public TypeArgumentListSyntax AddArguments(params TypeSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for alias qualified name.</summary>
  public sealed partial class AliasQualifiedNameSyntax : NameSyntax
  {
    private IdentifierNameSyntax alias;
    private SimpleNameSyntax name;

    internal AliasQualifiedNameSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
    public IdentifierNameSyntax Alias 
    {
        get
        {
            return this.GetRedAtZero(ref this.alias);
        }
    }

    /// <summary>SyntaxToken representing colon colon.</summary>
    public SyntaxToken ColonColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AliasQualifiedNameSyntax)this.Green).colonColonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
    public SimpleNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.alias);
            case 2: return this.GetRed(ref this.name, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.alias;
            case 2: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAliasQualifiedName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAliasQualifiedName(this);
    }

    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
        if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name)
        {
            var newNode = SyntaxFactory.AliasQualifiedName(alias, colonColonToken, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AliasQualifiedNameSyntax WithAlias(IdentifierNameSyntax alias)
    {
        return this.Update(alias, this.ColonColonToken, this.Name);
    }

    public AliasQualifiedNameSyntax WithColonColonToken(SyntaxToken colonColonToken)
    {
        return this.Update(this.Alias, colonColonToken, this.Name);
    }

    public AliasQualifiedNameSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.Alias, this.ColonColonToken, name);
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class TypeSyntax : ExpressionSyntax
  {
    internal TypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class ConstLiteralTypeSyntax : TypeSyntax
  {
    private LiteralExpressionSyntax value;

    internal ConstLiteralTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>The value of this type syntax.</summary>
    public LiteralExpressionSyntax Value 
    {
        get
        {
            return this.GetRedAtZero(ref this.value);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.value);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstLiteralType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstLiteralType(this);
    }

    public ConstLiteralTypeSyntax Update(LiteralExpressionSyntax value)
    {
        if (value != this.Value)
        {
            var newNode = SyntaxFactory.ConstLiteralType(value);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstLiteralTypeSyntax WithValue(LiteralExpressionSyntax value)
    {
        return this.Update(value);
    }
  }

  /// <summary>Class which represents the syntax node for predefined types.</summary>
  public sealed partial class PredefinedTypeSyntax : TypeSyntax
  {
    internal PredefinedTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PredefinedTypeSyntax)this.Green).keyword, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPredefinedType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPredefinedType(this);
    }

    public PredefinedTypeSyntax Update(SyntaxToken keyword)
    {
        if (keyword != this.Keyword)
        {
            var newNode = SyntaxFactory.PredefinedType(keyword);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PredefinedTypeSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword);
    }
  }

  /// <summary>Class which represents the syntax node for the array type.</summary>
  public sealed partial class ArrayTypeSyntax : TypeSyntax
  {
    private SyntaxNode rankSpecifiers;
    private TypeSyntax elementType;

    internal ArrayTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
    public SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers 
    {
        get
        {
            return new SyntaxList<ArrayRankSpecifierSyntax>(this.GetRed(ref this.rankSpecifiers, 0));
        }
    }

    /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
    public TypeSyntax ElementType 
    {
        get
        {
            return this.GetRed(ref this.elementType, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.rankSpecifiers);
            case 1: return this.GetRed(ref this.elementType, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.rankSpecifiers;
            case 1: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayType(this);
    }

    public ArrayTypeSyntax Update(SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers, TypeSyntax elementType)
    {
        if (rankSpecifiers != this.RankSpecifiers || elementType != this.ElementType)
        {
            var newNode = SyntaxFactory.ArrayType(rankSpecifiers, elementType);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayTypeSyntax WithRankSpecifiers(SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        return this.Update(rankSpecifiers, this.ElementType);
    }

    public ArrayTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(this.RankSpecifiers, elementType);
    }

    public ArrayTypeSyntax AddRankSpecifiers(params ArrayRankSpecifierSyntax[] items)
    {
        return this.WithRankSpecifiers(this.RankSpecifiers.AddRange(items));
    }
  }

  public sealed partial class ArrayRankSpecifierSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax sizes;

    internal ArrayRankSpecifierSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ArrayRankSpecifierSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    public ExpressionSyntax Sizes 
    {
        get
        {
            return this.GetRed(ref this.sizes, 1);
        }
    }

    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ArrayRankSpecifierSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.sizes, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.sizes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayRankSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayRankSpecifier(this);
    }

    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, ExpressionSyntax sizes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayRankSpecifierSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Sizes, this.CloseBracketToken);
    }

    public ArrayRankSpecifierSyntax WithSizes(ExpressionSyntax sizes)
    {
        return this.Update(this.OpenBracketToken, sizes, this.CloseBracketToken);
    }

    public ArrayRankSpecifierSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Sizes, closeBracketToken);
    }
  }

  /// <summary>Class which represents the syntax node for pointer type.</summary>
  public sealed partial class PointerTypeSyntax : TypeSyntax
  {
    private TypeSyntax elementType;

    internal PointerTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the asterisk.</summary>
    public SyntaxToken AsteriskToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PointerTypeSyntax)this.Green).asteriskToken, this.Position, 0); }
    }

    /// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
    public TypeSyntax ElementType 
    {
        get
        {
            return this.GetRed(ref this.elementType, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.elementType, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPointerType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPointerType(this);
    }

    public PointerTypeSyntax Update(SyntaxToken asteriskToken, TypeSyntax elementType)
    {
        if (asteriskToken != this.AsteriskToken || elementType != this.ElementType)
        {
            var newNode = SyntaxFactory.PointerType(asteriskToken, elementType);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PointerTypeSyntax WithAsteriskToken(SyntaxToken asteriskToken)
    {
        return this.Update(asteriskToken, this.ElementType);
    }

    public PointerTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(this.AsteriskToken, elementType);
    }
  }

  /// <summary>Class which represents the syntax node for a nullable type.</summary>
  public sealed partial class NullableTypeSyntax : TypeSyntax
  {
    private TypeSyntax elementType;

    internal NullableTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NullableTypeSyntax)this.Green).questionToken, this.Position, 0); }
    }

    /// <summary>TypeSyntax node representing the type of the element.</summary>
    public TypeSyntax ElementType 
    {
        get
        {
            return this.GetRed(ref this.elementType, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.elementType, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNullableType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNullableType(this);
    }

    public NullableTypeSyntax Update(SyntaxToken questionToken, TypeSyntax elementType)
    {
        if (questionToken != this.QuestionToken || elementType != this.ElementType)
        {
            var newNode = SyntaxFactory.NullableType(questionToken, elementType);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NullableTypeSyntax WithQuestionToken(SyntaxToken questionToken)
    {
        return this.Update(questionToken, this.ElementType);
    }

    public NullableTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(this.QuestionToken, elementType);
    }
  }

  /// <summary>Class which represents the syntax node for tuple type.</summary>
  public sealed partial class TupleTypeSyntax : TypeSyntax
  {
    private SyntaxNode elements;

    internal TupleTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TupleTypeSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public SeparatedSyntaxList<TupleElementSyntax> Elements 
    {
        get
        {
            var red = this.GetRed(ref this.elements, 1);
            if (red != null)
                return new SeparatedSyntaxList<TupleElementSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<TupleElementSyntax>);
        }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TupleTypeSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.elements, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.elements;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleType(this);
    }

    public TupleTypeSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || elements != this.Elements || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleType(openParenToken, elements, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TupleTypeSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Elements, this.CloseParenToken);
    }

    public TupleTypeSyntax WithElements(SeparatedSyntaxList<TupleElementSyntax> elements)
    {
        return this.Update(this.OpenParenToken, elements, this.CloseParenToken);
    }

    public TupleTypeSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Elements, closeParenToken);
    }

    public TupleTypeSyntax AddElements(params TupleElementSyntax[] items)
    {
        return this.WithElements(this.Elements.AddRange(items));
    }
  }

  /// <summary>Tuple type element.</summary>
  public sealed partial class TupleElementSyntax : CSharpSyntaxNode
  {
    private TypeSyntax type;

    internal TupleElementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the type of the tuple element.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    /// <summary>Gets the name of the tuple element.</summary>
    public SyntaxToken Identifier 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TupleElementSyntax)this.Green).identifier;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleElement(this);
    }

    public TupleElementSyntax Update(TypeSyntax type, SyntaxToken identifier)
    {
        if (type != this.Type || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.TupleElement(type, identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TupleElementSyntax WithType(TypeSyntax type)
    {
        return this.Update(type, this.Identifier);
    }

    public TupleElementSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Type, identifier);
    }
  }

  /// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
  public sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
  {
    internal OmittedTypeArgumentSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the omitted type argument.</summary>
    public SyntaxToken OmittedTypeArgumentToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OmittedTypeArgumentSyntax)this.Green).omittedTypeArgumentToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedTypeArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOmittedTypeArgument(this);
    }

    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)
    {
        if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken)
        {
            var newNode = SyntaxFactory.OmittedTypeArgument(omittedTypeArgumentToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OmittedTypeArgumentSyntax WithOmittedTypeArgumentToken(SyntaxToken omittedTypeArgumentToken)
    {
        return this.Update(omittedTypeArgumentToken);
    }
  }

  /// <summary>Class which represents the syntax node for a readonly/transient type.</summary>
  public abstract partial class ExtendedTypeSyntax : TypeSyntax
  {
    internal ExtendedTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }
    public ExtendedTypeSyntax WithModifiers(SyntaxTokenList modifiers) => WithModifiersCore(modifiers);
    internal abstract ExtendedTypeSyntax WithModifiersCore(SyntaxTokenList modifiers);

    public ExtendedTypeSyntax AddModifiers(params SyntaxToken[] items) => AddModifiersCore(items);
    internal abstract ExtendedTypeSyntax AddModifiersCore(params SyntaxToken[] items);

    /// <summary>The ElementType for which the modifiers are applied (e.g readonly, transient...).</summary>
    public abstract TypeSyntax ElementType { get; }
    public ExtendedTypeSyntax WithElementType(TypeSyntax elementType) => WithElementTypeCore(elementType);
    internal abstract ExtendedTypeSyntax WithElementTypeCore(TypeSyntax elementType);
  }

  /// <summary>Class which represents the syntax node for a readonly/transient type.</summary>
  public sealed partial class SimpleExtendedTypeSyntax : ExtendedTypeSyntax
  {
    private TypeSyntax elementType;

    internal SimpleExtendedTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    public override TypeSyntax ElementType 
    {
        get
        {
            return this.GetRed(ref this.elementType, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.elementType, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleExtendedType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleExtendedType(this);
    }

    public SimpleExtendedTypeSyntax Update(SyntaxTokenList modifiers, TypeSyntax elementType)
    {
        if (modifiers != this.Modifiers || elementType != this.ElementType)
        {
            var newNode = SyntaxFactory.SimpleExtendedType(modifiers, elementType);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override ExtendedTypeSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new SimpleExtendedTypeSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(modifiers, this.ElementType);
    }

    internal override ExtendedTypeSyntax WithElementTypeCore(TypeSyntax elementType) => WithElementType(elementType);
    public new SimpleExtendedTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(this.Modifiers, elementType);
    }
    internal override ExtendedTypeSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new SimpleExtendedTypeSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
  }

  /// <summary>The ref modifier of a method's return value or a local.</summary>
  public sealed partial class RefTypeSyntax : ExtendedTypeSyntax
  {
    private TypeSyntax elementType;

    internal RefTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LetKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefTypeSyntax)this.Green).letKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    public SyntaxToken RefKindKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefTypeSyntax)this.Green).refKindKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(2);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxTokenList);
        }
    }

    public override TypeSyntax ElementType 
    {
        get
        {
            return this.GetRed(ref this.elementType, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 3: return this.GetRed(ref this.elementType, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 3: return this.elementType;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefType(this);
    }

    public RefTypeSyntax Update(SyntaxToken letKeyword, SyntaxToken refKindKeyword, SyntaxTokenList modifiers, TypeSyntax elementType)
    {
        if (letKeyword != this.LetKeyword || refKindKeyword != this.RefKindKeyword || modifiers != this.Modifiers || elementType != this.ElementType)
        {
            var newNode = SyntaxFactory.RefType(letKeyword, refKindKeyword, modifiers, elementType);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RefTypeSyntax WithLetKeyword(SyntaxToken letKeyword)
    {
        return this.Update(letKeyword, this.RefKindKeyword, this.Modifiers, this.ElementType);
    }

    public RefTypeSyntax WithRefKindKeyword(SyntaxToken refKindKeyword)
    {
        return this.Update(this.LetKeyword, refKindKeyword, this.Modifiers, this.ElementType);
    }

    internal override ExtendedTypeSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new RefTypeSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.LetKeyword, this.RefKindKeyword, modifiers, this.ElementType);
    }

    internal override ExtendedTypeSyntax WithElementTypeCore(TypeSyntax elementType) => WithElementType(elementType);
    public new RefTypeSyntax WithElementType(TypeSyntax elementType)
    {
        return this.Update(this.LetKeyword, this.RefKindKeyword, this.Modifiers, elementType);
    }
    internal override ExtendedTypeSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new RefTypeSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
  }

  /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class ExpressionSyntax : CSharpSyntaxNode
  {
    internal ExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
  public sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal ParenthesizedExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParenthesizedExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedExpression(this);
    }

    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParenthesizedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Expression, this.CloseParenToken);
    }

    public ParenthesizedExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.OpenParenToken, expression, this.CloseParenToken);
    }

    public ParenthesizedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for tuple expression.</summary>
  public sealed partial class TupleExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode arguments;

    internal TupleExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TupleExpressionSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public SeparatedSyntaxList<ArgumentSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<ArgumentSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ArgumentSyntax>);
        }
    }

    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TupleExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleExpression(this);
    }

    public TupleExpressionSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleExpression(openParenToken, arguments, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TupleExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Arguments, this.CloseParenToken);
    }

    public TupleExpressionSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        return this.Update(this.OpenParenToken, arguments, this.CloseParenToken);
    }

    public TupleExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Arguments, closeParenToken);
    }

    public TupleExpressionSyntax AddArguments(params ArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
  public sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax operand;

    internal PrefixUnaryExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax)this.Green).operatorToken, this.Position, 0); }
    }

    /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
    public ExpressionSyntax Operand 
    {
        get
        {
            return this.GetRed(ref this.operand, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.operand, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.operand;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPrefixUnaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPrefixUnaryExpression(this);
    }

    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
    {
        if (operatorToken != this.OperatorToken || operand != this.Operand)
        {
            var newNode = SyntaxFactory.PrefixUnaryExpression(this.Kind(), operatorToken, operand);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PrefixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(operatorToken, this.Operand);
    }

    public PrefixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)
    {
        return this.Update(this.OperatorToken, operand);
    }
  }

  /// <summary>Class which represents the syntax node for an "await" expression.</summary>
  public sealed partial class AwaitExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal AwaitExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the kind "await" keyword.</summary>
    public SyntaxToken AwaitKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AwaitExpressionSyntax)this.Green).awaitKeyword, this.Position, 0); }
    }

    /// <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAwaitExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAwaitExpression(this);
    }

    public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
        if (awaitKeyword != this.AwaitKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AwaitExpression(awaitKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AwaitExpressionSyntax WithAwaitKeyword(SyntaxToken awaitKeyword)
    {
        return this.Update(awaitKeyword, this.Expression);
    }

    public AwaitExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.AwaitKeyword, expression);
    }
  }

  /// <summary>Class which represents the syntax node for an "try" expression.</summary>
  public sealed partial class TryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal TryExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the kind "try" keyword.</summary>
    public SyntaxToken TryKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TryExpressionSyntax)this.Green).tryKeyword, this.Position, 0); }
    }

    /// <summary>ExpressionSyntax representing the operand of the "try" operator.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTryExpression(this);
    }

    public TryExpressionSyntax Update(SyntaxToken tryKeyword, ExpressionSyntax expression)
    {
        if (tryKeyword != this.TryKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.TryExpression(tryKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TryExpressionSyntax WithTryKeyword(SyntaxToken tryKeyword)
    {
        return this.Update(tryKeyword, this.Expression);
    }

    public TryExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.TryKeyword, expression);
    }
  }

  /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
  public sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax operand;

    internal PostfixUnaryExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
    public ExpressionSyntax Operand 
    {
        get
        {
            return this.GetRedAtZero(ref this.operand);
        }
    }

    /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.operand);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operand;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPostfixUnaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPostfixUnaryExpression(this);
    }

    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)
    {
        if (operand != this.Operand || operatorToken != this.OperatorToken)
        {
            var newNode = SyntaxFactory.PostfixUnaryExpression(this.Kind(), operand, operatorToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PostfixUnaryExpressionSyntax WithOperand(ExpressionSyntax operand)
    {
        return this.Update(operand, this.OperatorToken);
    }

    public PostfixUnaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Operand, operatorToken);
    }
  }

  /// <summary>Class which represents the syntax node for member access expression.</summary>
  public sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private SimpleNameSyntax name;

    internal MemberAccessExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MemberAccessExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
    public SimpleNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 2: return this.GetRed(ref this.name, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 2: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMemberAccessExpression(this);
    }

    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberAccessExpression(this.Kind(), expression, operatorToken, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MemberAccessExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.OperatorToken, this.Name);
    }

    public MemberAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Expression, operatorToken, this.Name);
    }

    public MemberAccessExpressionSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.Expression, this.OperatorToken, name);
    }
  }

  /// <summary>Class which represents the syntax node for conditional access expression.</summary>
  public sealed partial class ConditionalAccessExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private ExpressionSyntax whenNotNull;

    internal ConditionalAccessExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
    public ExpressionSyntax WhenNotNull 
    {
        get
        {
            return this.GetRed(ref this.whenNotNull, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 2: return this.GetRed(ref this.whenNotNull, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 2: return this.whenNotNull;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConditionalAccessExpression(this);
    }

    public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || whenNotNull != this.WhenNotNull)
        {
            var newNode = SyntaxFactory.ConditionalAccessExpression(expression, operatorToken, whenNotNull);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConditionalAccessExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.OperatorToken, this.WhenNotNull);
    }

    public ConditionalAccessExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Expression, operatorToken, this.WhenNotNull);
    }

    public ConditionalAccessExpressionSyntax WithWhenNotNull(ExpressionSyntax whenNotNull)
    {
        return this.Update(this.Expression, this.OperatorToken, whenNotNull);
    }
  }

  /// <summary>Class which represents the syntax node for member binding expression.</summary>
  public sealed partial class MemberBindingExpressionSyntax : ExpressionSyntax
  {
    private SimpleNameSyntax name;

    internal MemberBindingExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing dot.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MemberBindingExpressionSyntax)this.Green).operatorToken, this.Position, 0); }
    }

    /// <summary>SimpleNameSyntax node representing the member being bound to.</summary>
    public SimpleNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberBindingExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMemberBindingExpression(this);
    }

    public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberBindingExpression(operatorToken, name);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MemberBindingExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(operatorToken, this.Name);
    }

    public MemberBindingExpressionSyntax WithName(SimpleNameSyntax name)
    {
        return this.Update(this.OperatorToken, name);
    }
  }

  /// <summary>Class which represents the syntax node for element binding expression.</summary>
  public sealed partial class ElementBindingExpressionSyntax : ExpressionSyntax
  {
    private BracketedArgumentListSyntax argumentList;

    internal ElementBindingExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
    public BracketedArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRedAtZero(ref this.argumentList);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.argumentList);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementBindingExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElementBindingExpression(this);
    }

    public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementBindingExpression(argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElementBindingExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(argumentList);
    }

    public ElementBindingExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for a range expression.</summary>
  public sealed partial class RangeExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax leftOperand;
    private ExpressionSyntax rightOperand;

    internal RangeExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
    public ExpressionSyntax LeftOperand 
    {
        get
        {
            return this.GetRedAtZero(ref this.leftOperand);
        }
    }

    /// <summary>SyntaxToken representing the operator of the range expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RangeExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
    public ExpressionSyntax RightOperand 
    {
        get
        {
            return this.GetRed(ref this.rightOperand, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.leftOperand);
            case 2: return this.GetRed(ref this.rightOperand, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.leftOperand;
            case 2: return this.rightOperand;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRangeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRangeExpression(this);
    }

    public RangeExpressionSyntax Update(ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
    {
        if (leftOperand != this.LeftOperand || operatorToken != this.OperatorToken || rightOperand != this.RightOperand)
        {
            var newNode = SyntaxFactory.RangeExpression(leftOperand, operatorToken, rightOperand);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RangeExpressionSyntax WithLeftOperand(ExpressionSyntax leftOperand)
    {
        return this.Update(leftOperand, this.OperatorToken, this.RightOperand);
    }

    public RangeExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.LeftOperand, operatorToken, this.RightOperand);
    }

    public RangeExpressionSyntax WithRightOperand(ExpressionSyntax rightOperand)
    {
        return this.Update(this.LeftOperand, this.OperatorToken, rightOperand);
    }
  }

  /// <summary>Class which represents the syntax node for implicit element access expression.</summary>
  public sealed partial class ImplicitElementAccessSyntax : ExpressionSyntax
  {
    private BracketedArgumentListSyntax argumentList;

    internal ImplicitElementAccessSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRedAtZero(ref this.argumentList);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.argumentList);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitElementAccess(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitElementAccess(this);
    }

    public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ImplicitElementAccess(argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ImplicitElementAccessSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(argumentList);
    }

    public ImplicitElementAccessSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Class which represents an expression that has a binary operator.</summary>
  public sealed partial class BinaryExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax left;
    private ExpressionSyntax right;

    internal BinaryExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
    public ExpressionSyntax Left 
    {
        get
        {
            return this.GetRedAtZero(ref this.left);
        }
    }

    /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BinaryExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
    public ExpressionSyntax Right 
    {
        get
        {
            return this.GetRed(ref this.right, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.left);
            case 2: return this.GetRed(ref this.right, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBinaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBinaryExpression(this);
    }

    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.BinaryExpression(this.Kind(), left, operatorToken, right);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BinaryExpressionSyntax WithLeft(ExpressionSyntax left)
    {
        return this.Update(left, this.OperatorToken, this.Right);
    }

    public BinaryExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Left, operatorToken, this.Right);
    }

    public BinaryExpressionSyntax WithRight(ExpressionSyntax right)
    {
        return this.Update(this.Left, this.OperatorToken, right);
    }
  }

  /// <summary>Class which represents an expression that has an assignment operator.</summary>
  public sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax left;
    private ExpressionSyntax right;

    internal AssignmentExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
    public ExpressionSyntax Left 
    {
        get
        {
            return this.GetRedAtZero(ref this.left);
        }
    }

    /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AssignmentExpressionSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
    public ExpressionSyntax Right 
    {
        get
        {
            return this.GetRed(ref this.right, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.left);
            case 2: return this.GetRed(ref this.right, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 2: return this.right;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAssignmentExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAssignmentExpression(this);
    }

    public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.AssignmentExpression(this.Kind(), left, operatorToken, right);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AssignmentExpressionSyntax WithLeft(ExpressionSyntax left)
    {
        return this.Update(left, this.OperatorToken, this.Right);
    }

    public AssignmentExpressionSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.Left, operatorToken, this.Right);
    }

    public AssignmentExpressionSyntax WithRight(ExpressionSyntax right)
    {
        return this.Update(this.Left, this.OperatorToken, right);
    }
  }

  /// <summary>Class which represents the syntax node for conditional expression.</summary>
  public sealed partial class IfExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax condition;
    private ExpressionSyntax whenTrue;
    private ExpressionSyntax whenFalse;

    internal IfExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the if keyword.
    /// </summary>
    public SyntaxToken IfKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfExpressionSyntax)this.Green).ifKeyword, this.Position, 0); }
    }

    /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 1);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the then keyword.
    /// </summary>
    public SyntaxToken ThenKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfExpressionSyntax)this.Green).thenKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
    public ExpressionSyntax WhenTrue 
    {
        get
        {
            return this.GetRed(ref this.whenTrue, 3);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the else keyword.
    /// </summary>
    public SyntaxToken ElseKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfExpressionSyntax)this.Green).elseKeyword, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
    public ExpressionSyntax WhenFalse 
    {
        get
        {
            return this.GetRed(ref this.whenFalse, 5);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            case 3: return this.GetRed(ref this.whenTrue, 3);
            case 5: return this.GetRed(ref this.whenFalse, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            case 3: return this.whenTrue;
            case 5: return this.whenFalse;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfExpression(this);
    }

    public IfExpressionSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, ExpressionSyntax whenTrue, SyntaxToken elseKeyword, ExpressionSyntax whenFalse)
    {
        if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || whenTrue != this.WhenTrue || elseKeyword != this.ElseKeyword || whenFalse != this.WhenFalse)
        {
            var newNode = SyntaxFactory.IfExpression(ifKeyword, condition, thenKeyword, whenTrue, elseKeyword, whenFalse);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IfExpressionSyntax WithIfKeyword(SyntaxToken ifKeyword)
    {
        return this.Update(ifKeyword, this.Condition, this.ThenKeyword, this.WhenTrue, this.ElseKeyword, this.WhenFalse);
    }

    public IfExpressionSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.IfKeyword, condition, this.ThenKeyword, this.WhenTrue, this.ElseKeyword, this.WhenFalse);
    }

    public IfExpressionSyntax WithThenKeyword(SyntaxToken thenKeyword)
    {
        return this.Update(this.IfKeyword, this.Condition, thenKeyword, this.WhenTrue, this.ElseKeyword, this.WhenFalse);
    }

    public IfExpressionSyntax WithWhenTrue(ExpressionSyntax whenTrue)
    {
        return this.Update(this.IfKeyword, this.Condition, this.ThenKeyword, whenTrue, this.ElseKeyword, this.WhenFalse);
    }

    public IfExpressionSyntax WithElseKeyword(SyntaxToken elseKeyword)
    {
        return this.Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.WhenTrue, elseKeyword, this.WhenFalse);
    }

    public IfExpressionSyntax WithWhenFalse(ExpressionSyntax whenFalse)
    {
        return this.Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.WhenTrue, this.ElseKeyword, whenFalse);
    }
  }

  /// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class InstanceExpressionSyntax : ExpressionSyntax
  {
    internal InstanceExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Class which represents the syntax node for a this expression.</summary>
  public sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
  {
    internal ThisExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the this keyword.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ThisExpressionSyntax)this.Green).token, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThisExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThisExpression(this);
    }

    public ThisExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.ThisExpression(token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ThisExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for a base expression.</summary>
  public sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
  {
    internal BaseExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the base keyword.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BaseExpressionSyntax)this.Green).token, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBaseExpression(this);
    }

    public BaseExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.BaseExpression(token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BaseExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for a literal expression.</summary>
  public sealed partial class LiteralExpressionSyntax : ExpressionSyntax
  {
    internal LiteralExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
    public SyntaxToken Token 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LiteralExpressionSyntax)this.Green).token, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLiteralExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLiteralExpression(this);
    }

    public LiteralExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.LiteralExpression(this.Kind(), token);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LiteralExpressionSyntax WithToken(SyntaxToken token)
    {
        return this.Update(token);
    }
  }

  /// <summary>Class which represents the syntax node for MakeRef expression.</summary>
  public sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal MakeRefExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MakeRefExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MakeRefExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MakeRefExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMakeRefExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMakeRefExpression(this);
    }

    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public MakeRefExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public MakeRefExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for RefType expression.</summary>
  public sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal RefTypeExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefTypeExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefTypeExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefTypeExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefTypeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefTypeExpression(this);
    }

    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RefTypeExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public RefTypeExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for RefValue expression.</summary>
  public sealed partial class RefValueExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private TypeSyntax type;

    internal RefValueExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the RefValueKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefValueExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefValueExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Typed reference expression.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>Comma separating the arguments.</summary>
    public SyntaxToken Comma 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefValueExpressionSyntax)this.Green).comma, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>The type of the value.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 4);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefValueExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 4: return this.GetRed(ref this.type, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 4: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefValueExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefValueExpression(this);
    }

    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RefValueExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.Comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithComma(SyntaxToken comma)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, comma, this.Type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, this.Comma, type, this.CloseParenToken);
    }

    public RefValueExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, this.Comma, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
  public sealed partial class CheckedExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal CheckedExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CheckedExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CheckedExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CheckedExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCheckedExpression(this);
    }

    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CheckedExpression(this.Kind(), keyword, openParenToken, expression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CheckedExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Keyword, this.OpenParenToken, expression, this.CloseParenToken);
    }

    public CheckedExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Expression, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for Default expression.</summary>
  public sealed partial class DefaultExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal DefaultExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the DefaultKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefaultExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefaultExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefaultExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefaultExpression(this);
    }

    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.DefaultExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DefaultExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public DefaultExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for TypeOf expression.</summary>
  public sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal TypeOfExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeOfExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeOfExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>The expression to return type of.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeOfExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeOfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeOfExpression(this);
    }

    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeOfExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public TypeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for SizeOf expression.</summary>
  public sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;

    internal SizeOfExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SizeOfExpressionSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SizeOfExpressionSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SizeOfExpressionSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSizeOfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSizeOfExpression(this);
    }

    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SizeOfExpressionSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.OpenParenToken, this.Type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.Keyword, openParenToken, this.Type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Keyword, this.OpenParenToken, type, this.CloseParenToken);
    }

    public SizeOfExpressionSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.Keyword, this.OpenParenToken, this.Type, closeParenToken);
    }
  }

  /// <summary>Class which represents the syntax node for invocation expression.</summary>
  public sealed partial class InvocationExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private ArgumentListSyntax argumentList;

    internal InvocationExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
    public ArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 1: return this.GetRed(ref this.argumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInvocationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInvocationExpression(this);
    }

    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.InvocationExpression(expression, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InvocationExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.ArgumentList);
    }

    public InvocationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.Expression, argumentList);
    }

    public InvocationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for element access expression.</summary>
  public sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private BracketedArgumentListSyntax argumentList;

    internal ElementAccessExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 1: return this.GetRed(ref this.argumentList, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElementAccessExpression(this);
    }

    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementAccessExpression(expression, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElementAccessExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.ArgumentList);
    }

    public ElementAccessExpressionSyntax WithArgumentList(BracketedArgumentListSyntax argumentList)
    {
        return this.Update(this.Expression, argumentList);
    }

    public ElementAccessExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class BaseArgumentListSyntax : CSharpSyntaxNode
  {
    internal BaseArgumentListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
    public abstract SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
    public BaseArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments) => WithArgumentsCore(arguments);
    internal abstract BaseArgumentListSyntax WithArgumentsCore(SeparatedSyntaxList<ArgumentSyntax> arguments);

    public BaseArgumentListSyntax AddArguments(params ArgumentSyntax[] items) => AddArgumentsCore(items);
    internal abstract BaseArgumentListSyntax AddArgumentsCore(params ArgumentSyntax[] items);
  }

  /// <summary>Class which represents the syntax node for the list of arguments.</summary>
  public sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
  {
    private SyntaxNode arguments;

    internal ArgumentListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ArgumentListSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<ArgumentSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ArgumentSyntax>);
        }
    }

    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ArgumentListSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArgumentList(this);
    }

    public ArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Arguments, this.CloseParenToken);
    }

    internal override BaseArgumentListSyntax WithArgumentsCore(SeparatedSyntaxList<ArgumentSyntax> arguments) => WithArguments(arguments);
    public new ArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        return this.Update(this.OpenParenToken, arguments, this.CloseParenToken);
    }

    public ArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Arguments, closeParenToken);
    }
    internal override BaseArgumentListSyntax AddArgumentsCore(params ArgumentSyntax[] items) => AddArguments(items);

    public new ArgumentListSyntax AddArguments(params ArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
  public sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
  {
    private SyntaxNode arguments;

    internal BracketedArgumentListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BracketedArgumentListSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override SeparatedSyntaxList<ArgumentSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<ArgumentSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ArgumentSyntax>);
        }
    }

    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BracketedArgumentListSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBracketedArgumentList(this);
    }

    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BracketedArgumentListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Arguments, this.CloseBracketToken);
    }

    internal override BaseArgumentListSyntax WithArgumentsCore(SeparatedSyntaxList<ArgumentSyntax> arguments) => WithArguments(arguments);
    public new BracketedArgumentListSyntax WithArguments(SeparatedSyntaxList<ArgumentSyntax> arguments)
    {
        return this.Update(this.OpenBracketToken, arguments, this.CloseBracketToken);
    }

    public BracketedArgumentListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Arguments, closeBracketToken);
    }
    internal override BaseArgumentListSyntax AddArgumentsCore(params ArgumentSyntax[] items) => AddArguments(items);

    public new BracketedArgumentListSyntax AddArguments(params ArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for argument.</summary>
  public sealed partial class ArgumentSyntax : CSharpSyntaxNode
  {
    private NameColonSyntax nameColon;
    private ExpressionSyntax expression;

    internal ArgumentSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
    public NameColonSyntax NameColon 
    {
        get
        {
            return this.GetRedAtZero(ref this.nameColon);
        }
    }

    /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
    public SyntaxToken RefKindKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ArgumentSyntax)this.Green).refKindKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    /// <summary>ExpressionSyntax node representing the argument.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.nameColon);
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArgument(this);
    }

    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
    {
        if (nameColon != this.NameColon || refKindKeyword != this.RefKindKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.Argument(nameColon, refKindKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArgumentSyntax WithNameColon(NameColonSyntax nameColon)
    {
        return this.Update(nameColon, this.RefKindKeyword, this.Expression);
    }

    public ArgumentSyntax WithRefKindKeyword(SyntaxToken refKindKeyword)
    {
        return this.Update(this.NameColon, refKindKeyword, this.Expression);
    }

    public ArgumentSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameColon, this.RefKindKeyword, expression);
    }
  }

  /// <summary>Class which represents the syntax node for name colon syntax.</summary>
  public sealed partial class NameColonSyntax : CSharpSyntaxNode
  {
    private IdentifierNameSyntax name;

    internal NameColonSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
    public IdentifierNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    /// <summary>SyntaxToken representing colon.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NameColonSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameColon(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameColon(this);
    }

    public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
        if (name != this.Name || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.NameColon(name, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NameColonSyntax WithName(IdentifierNameSyntax name)
    {
        return this.Update(name, this.ColonToken);
    }

    public NameColonSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Name, colonToken);
    }
  }

  /// <summary>Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.</summary>
  public sealed partial class DeclarationExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;
    private VariableDesignationSyntax designation;

    internal DeclarationExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    /// <summary>Declaration representing the variable declared in an out parameter or deconstruction.</summary>
    public VariableDesignationSyntax Designation 
    {
        get
        {
            return this.GetRed(ref this.designation, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            case 1: return this.GetRed(ref this.designation, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.designation;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDeclarationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDeclarationExpression(this);
    }

    public DeclarationExpressionSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)
    {
        if (type != this.Type || designation != this.Designation)
        {
            var newNode = SyntaxFactory.DeclarationExpression(type, designation);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DeclarationExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(type, this.Designation);
    }

    public DeclarationExpressionSyntax WithDesignation(VariableDesignationSyntax designation)
    {
        return this.Update(this.Type, designation);
    }
  }

  /// <summary>Class which represents the syntax node for cast expression.</summary>
  public sealed partial class CastExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private TypeSyntax type;

    internal CastExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    /// <summary>SyntaxToken representing the as keyword.</summary>
    public SyntaxToken AsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CastExpressionSyntax)this.Green).asKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>TypeSyntax node representing the type to which the expression is being cast.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCastExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCastExpression(this);
    }

    public CastExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken asKeyword, TypeSyntax type)
    {
        if (expression != this.Expression || asKeyword != this.AsKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.CastExpression(expression, asKeyword, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CastExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.AsKeyword, this.Type);
    }

    public CastExpressionSyntax WithAsKeyword(SyntaxToken asKeyword)
    {
        return this.Update(this.Expression, asKeyword, this.Type);
    }

    public CastExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.Expression, this.AsKeyword, type);
    }
  }

  /// <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
  public abstract partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
  {
    internal AnonymousFunctionExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public abstract SyntaxToken AsyncKeyword { get; }
    public AnonymousFunctionExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword) => WithAsyncKeywordCore(asyncKeyword);
    internal abstract AnonymousFunctionExpressionSyntax WithAsyncKeywordCore(SyntaxToken asyncKeyword);

    /// <summary>ExpressionSyntax or BlockSyntax representing the body of the lambda expression.</summary>
    public abstract CSharpSyntaxNode Body { get; }
    public AnonymousFunctionExpressionSyntax WithBody(CSharpSyntaxNode body) => WithBodyCore(body);
    internal abstract AnonymousFunctionExpressionSyntax WithBodyCore(CSharpSyntaxNode body);
  }

  /// <summary>Class which represents the syntax node for anonymous method expression.</summary>
  public sealed partial class AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode body;

    internal AnonymousMethodExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax)this.Green).asyncKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    /// <summary>SyntaxToken representing the delegate keyword.</summary>
    public SyntaxToken DelegateKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax)this.Green).delegateKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
    public ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 2);
        }
    }

    /// <summary>BlockSyntax node representing the body of the anonymous method.</summary>
    public override CSharpSyntaxNode Body 
    {
        get
        {
            return this.GetRed(ref this.body, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.parameterList, 2);
            case 3: return this.GetRed(ref this.body, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.parameterList;
            case 3: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousMethodExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousMethodExpression(this);
    }

    public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || body != this.Body)
        {
            var newNode = SyntaxFactory.AnonymousMethodExpression(asyncKeyword, delegateKeyword, parameterList, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override AnonymousFunctionExpressionSyntax WithAsyncKeywordCore(SyntaxToken asyncKeyword) => WithAsyncKeyword(asyncKeyword);
    public new AnonymousMethodExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)
    {
        return this.Update(asyncKeyword, this.DelegateKeyword, this.ParameterList, this.Body);
    }

    public AnonymousMethodExpressionSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)
    {
        return this.Update(this.AsyncKeyword, delegateKeyword, this.ParameterList, this.Body);
    }

    public AnonymousMethodExpressionSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AsyncKeyword, this.DelegateKeyword, parameterList, this.Body);
    }

    internal override AnonymousFunctionExpressionSyntax WithBodyCore(CSharpSyntaxNode body) => WithBody(body);
    public new AnonymousMethodExpressionSyntax WithBody(CSharpSyntaxNode body)
    {
        return this.Update(this.AsyncKeyword, this.DelegateKeyword, this.ParameterList, body);
    }

    public AnonymousMethodExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        var parameterList = this.ParameterList ?? SyntaxFactory.ParameterList();
        return this.WithParameterList(parameterList.WithParameters(parameterList.Parameters.AddRange(items)));
    }
  }

  /// <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
  public abstract partial class LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    internal LambdaExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public abstract SyntaxToken ArrowToken { get; }
    public LambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken) => WithArrowTokenCore(arrowToken);
    internal abstract LambdaExpressionSyntax WithArrowTokenCore(SyntaxToken arrowToken);

    public new LambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword) => (LambdaExpressionSyntax)WithAsyncKeywordCore(asyncKeyword);
    public new LambdaExpressionSyntax WithBody(CSharpSyntaxNode body) => (LambdaExpressionSyntax)WithBodyCore(body);
  }

  /// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
  public sealed partial class SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    private ParameterSyntax parameter;
    private CSharpSyntaxNode body;

    internal SimpleLambdaExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax)this.Green).asyncKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    /// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
    public ParameterSyntax Parameter 
    {
        get
        {
            return this.GetRed(ref this.parameter, 1);
        }
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax)this.Green).arrowToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body 
    {
        get
        {
            return this.GetRed(ref this.body, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameter, 1);
            case 3: return this.GetRed(ref this.body, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameter;
            case 3: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleLambdaExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleLambdaExpression(this);
    }

    public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameter != this.Parameter || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = SyntaxFactory.SimpleLambdaExpression(asyncKeyword, parameter, arrowToken, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override AnonymousFunctionExpressionSyntax WithAsyncKeywordCore(SyntaxToken asyncKeyword) => WithAsyncKeyword(asyncKeyword);
    public new SimpleLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)
    {
        return this.Update(asyncKeyword, this.Parameter, this.ArrowToken, this.Body);
    }

    public SimpleLambdaExpressionSyntax WithParameter(ParameterSyntax parameter)
    {
        return this.Update(this.AsyncKeyword, parameter, this.ArrowToken, this.Body);
    }

    internal override LambdaExpressionSyntax WithArrowTokenCore(SyntaxToken arrowToken) => WithArrowToken(arrowToken);
    public new SimpleLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)
    {
        return this.Update(this.AsyncKeyword, this.Parameter, arrowToken, this.Body);
    }

    internal override AnonymousFunctionExpressionSyntax WithBodyCore(CSharpSyntaxNode body) => WithBody(body);
    public new SimpleLambdaExpressionSyntax WithBody(CSharpSyntaxNode body)
    {
        return this.Update(this.AsyncKeyword, this.Parameter, this.ArrowToken, body);
    }

    public SimpleLambdaExpressionSyntax AddParameterAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithParameter(this.Parameter.WithAttributeLists(this.Parameter.AttributeLists.AddRange(items)));
    }
  }

  public sealed partial class RefExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal RefExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken RefKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RefExpressionSyntax)this.Green).refKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefExpression(this);
    }

    public RefExpressionSyntax Update(SyntaxToken refKeyword, ExpressionSyntax expression)
    {
        if (refKeyword != this.RefKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.RefExpression(refKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RefExpressionSyntax WithRefKeyword(SyntaxToken refKeyword)
    {
        return this.Update(refKeyword, this.Expression);
    }

    public RefExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.RefKeyword, expression);
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
  public sealed partial class ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    private ParameterListSyntax parameterList;
    private CSharpSyntaxNode body;

    internal ParenthesizedLambdaExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax)this.Green).asyncKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    /// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
    public ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 1);
        }
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax)this.Green).arrowToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body 
    {
        get
        {
            return this.GetRed(ref this.body, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameterList, 1);
            case 3: return this.GetRed(ref this.body, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameterList;
            case 3: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedLambdaExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedLambdaExpression(this);
    }

    public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameterList != this.ParameterList || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = SyntaxFactory.ParenthesizedLambdaExpression(asyncKeyword, parameterList, arrowToken, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override AnonymousFunctionExpressionSyntax WithAsyncKeywordCore(SyntaxToken asyncKeyword) => WithAsyncKeyword(asyncKeyword);
    public new ParenthesizedLambdaExpressionSyntax WithAsyncKeyword(SyntaxToken asyncKeyword)
    {
        return this.Update(asyncKeyword, this.ParameterList, this.ArrowToken, this.Body);
    }

    public ParenthesizedLambdaExpressionSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AsyncKeyword, parameterList, this.ArrowToken, this.Body);
    }

    internal override LambdaExpressionSyntax WithArrowTokenCore(SyntaxToken arrowToken) => WithArrowToken(arrowToken);
    public new ParenthesizedLambdaExpressionSyntax WithArrowToken(SyntaxToken arrowToken)
    {
        return this.Update(this.AsyncKeyword, this.ParameterList, arrowToken, this.Body);
    }

    internal override AnonymousFunctionExpressionSyntax WithBodyCore(CSharpSyntaxNode body) => WithBody(body);
    public new ParenthesizedLambdaExpressionSyntax WithBody(CSharpSyntaxNode body)
    {
        return this.Update(this.AsyncKeyword, this.ParameterList, this.ArrowToken, body);
    }

    public ParenthesizedLambdaExpressionSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for initializer expression.</summary>
  public sealed partial class InitializerExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode expressions;

    internal InitializerExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InitializerExpressionSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
    public SeparatedSyntaxList<ExpressionSyntax> Expressions 
    {
        get
        {
            var red = this.GetRed(ref this.expressions, 1);
            if (red != null)
                return new SeparatedSyntaxList<ExpressionSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ExpressionSyntax>);
        }
    }

    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InitializerExpressionSyntax)this.Green).closeBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expressions, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expressions;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInitializerExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInitializerExpression(this);
    }

    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.InitializerExpression(this.Kind(), openBraceToken, expressions, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InitializerExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Expressions, this.CloseBraceToken);
    }

    public InitializerExpressionSyntax WithExpressions(SeparatedSyntaxList<ExpressionSyntax> expressions)
    {
        return this.Update(this.OpenBraceToken, expressions, this.CloseBraceToken);
    }

    public InitializerExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Expressions, closeBraceToken);
    }

    public InitializerExpressionSyntax AddExpressions(params ExpressionSyntax[] items)
    {
        return this.WithExpressions(this.Expressions.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for object creation expression.</summary>
  public sealed partial class ObjectCreationExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;
    private ArgumentListSyntax argumentList;
    private InitializerExpressionSyntax initializer;

    internal ObjectCreationExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ObjectCreationExpressionSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>TypeSyntax representing the type of the object being created.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
    public ArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 2);
        }
    }

    /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
    public InitializerExpressionSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 2: return this.GetRed(ref this.argumentList, 2);
            case 3: return this.GetRed(ref this.initializer, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 2: return this.argumentList;
            case 3: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitObjectCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitObjectCreationExpression(this);
    }

    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.Type, this.ArgumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.NewKeyword, type, this.ArgumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.NewKeyword, this.Type, argumentList, this.Initializer);
    }

    public ObjectCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.Type, this.ArgumentList, initializer);
    }

    public ObjectCreationExpressionSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        var argumentList = this.ArgumentList ?? SyntaxFactory.ArgumentList();
        return this.WithArgumentList(argumentList.WithArguments(argumentList.Arguments.AddRange(items)));
    }
  }

  public sealed partial class AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode
  {
    private NameEqualsSyntax nameEquals;
    private ExpressionSyntax expression;

    internal AnonymousObjectMemberDeclaratorSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
    public NameEqualsSyntax NameEquals 
    {
        get
        {
            return this.GetRedAtZero(ref this.nameEquals);
        }
    }

    /// <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.nameEquals);
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AnonymousObjectMemberDeclaratorSyntax WithNameEquals(NameEqualsSyntax nameEquals)
    {
        return this.Update(nameEquals, this.Expression);
    }

    public AnonymousObjectMemberDeclaratorSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameEquals, expression);
    }
  }

  /// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
  public sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode initializers;

    internal AnonymousObjectCreationExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax)this.Green).openBraceToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
    public SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers 
    {
        get
        {
            var red = this.GetRed(ref this.initializers, 2);
            if (red != null)
                return new SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(red, this.GetChildIndex(2));

            return default(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>);
        }
    }

    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax)this.Green).closeBraceToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.initializers, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.initializers;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
        if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AnonymousObjectCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenBraceToken, this.Initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.NewKeyword, openBraceToken, this.Initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithInitializers(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers)
    {
        return this.Update(this.NewKeyword, this.OpenBraceToken, initializers, this.CloseBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.NewKeyword, this.OpenBraceToken, this.Initializers, closeBraceToken);
    }

    public AnonymousObjectCreationExpressionSyntax AddInitializers(params AnonymousObjectMemberDeclaratorSyntax[] items)
    {
        return this.WithInitializers(this.Initializers.AddRange(items));
    }
  }

  /// <summary>Class which represents the syntax node for array creation expression.</summary>
  public sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private ArrayTypeSyntax type;
    private InitializerExpressionSyntax initializer;

    internal ArrayCreationExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ArrayCreationExpressionSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
    public ArrayTypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
    public InitializerExpressionSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 2: return this.GetRed(ref this.initializer, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayCreationExpression(this);
    }

    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ArrayCreationExpression(newKeyword, type, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.Type, this.Initializer);
    }

    public ArrayCreationExpressionSyntax WithType(ArrayTypeSyntax type)
    {
        return this.Update(this.NewKeyword, type, this.Initializer);
    }

    public ArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.Type, initializer);
    }

    public ArrayCreationExpressionSyntax AddTypeRankSpecifiers(params ArrayRankSpecifierSyntax[] items)
    {
        return this.WithType(this.Type.WithRankSpecifiers(this.Type.RankSpecifiers.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
  public sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private InitializerExpressionSyntax initializer;

    internal ImplicitArrayCreationExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax)this.Green).openBracketToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
    public SyntaxTokenList Commas 
    {
        get
        {
            var slot = this.Green.GetSlot(2);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax)this.Green).closeBracketToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
    public InitializerExpressionSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 4: return this.GetRed(ref this.initializer, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 4: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitArrayCreationExpression(this);
    }

    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ImplicitArrayCreationExpressionSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenBracketToken, this.Commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(this.NewKeyword, openBracketToken, this.Commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithCommas(SyntaxTokenList commas)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, commas, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, this.Commas, closeBracketToken, this.Initializer);
    }

    public ImplicitArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.NewKeyword, this.OpenBracketToken, this.Commas, this.CloseBracketToken, initializer);
    }

    public ImplicitArrayCreationExpressionSyntax AddCommas(params SyntaxToken[] items)
    {
        return this.WithCommas(this.Commas.AddRange(items));
    }

    public ImplicitArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items)
    {
        return this.WithInitializer(this.Initializer.WithExpressions(this.Initializer.Expressions.AddRange(items)));
    }
  }

  /// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
  public sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private TypeSyntax type;
    private InitializerExpressionSyntax initializer;

    internal StackAllocArrayCreationExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax)this.Green).stackAllocKeyword, this.Position, 0); }
    }

    /// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>InitializerExpressionSyntax node representing the initializer of the stackalloc array creation expression.</summary>
    public InitializerExpressionSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 2: return this.GetRed(ref this.initializer, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.StackAllocArrayCreationExpression(stackAllocKeyword, type, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public StackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword)
    {
        return this.Update(stackAllocKeyword, this.Type, this.Initializer);
    }

    public StackAllocArrayCreationExpressionSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.StackAllocKeyword, type, this.Initializer);
    }

    public StackAllocArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.StackAllocKeyword, this.Type, initializer);
    }
  }

  /// <summary>Class which represents the syntax node for implicit stackalloc array creation expression.</summary>
  public sealed partial class ImplicitStackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    private InitializerExpressionSyntax initializer;

    internal ImplicitStackAllocArrayCreationExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImplicitStackAllocArrayCreationExpressionSyntax)this.Green).stackAllocKeyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImplicitStackAllocArrayCreationExpressionSyntax)this.Green).openBracketToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImplicitStackAllocArrayCreationExpressionSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit stackalloc array creation expression.</summary>
    public InitializerExpressionSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 3: return this.GetRed(ref this.initializer, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 3: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitStackAllocArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitStackAllocArrayCreationExpression(this);
    }

    public ImplicitStackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || openBracketToken != this.OpenBracketToken || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ImplicitStackAllocArrayCreationExpression(stackAllocKeyword, openBracketToken, closeBracketToken, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ImplicitStackAllocArrayCreationExpressionSyntax WithStackAllocKeyword(SyntaxToken stackAllocKeyword)
    {
        return this.Update(stackAllocKeyword, this.OpenBracketToken, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitStackAllocArrayCreationExpressionSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(this.StackAllocKeyword, openBracketToken, this.CloseBracketToken, this.Initializer);
    }

    public ImplicitStackAllocArrayCreationExpressionSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.StackAllocKeyword, this.OpenBracketToken, closeBracketToken, this.Initializer);
    }

    public ImplicitStackAllocArrayCreationExpressionSyntax WithInitializer(InitializerExpressionSyntax initializer)
    {
        return this.Update(this.StackAllocKeyword, this.OpenBracketToken, this.CloseBracketToken, initializer);
    }

    public ImplicitStackAllocArrayCreationExpressionSyntax AddInitializerExpressions(params ExpressionSyntax[] items)
    {
        return this.WithInitializer(this.Initializer.WithExpressions(this.Initializer.Expressions.AddRange(items)));
    }
  }

  public abstract partial class QueryClauseSyntax : CSharpSyntaxNode
  {
    internal QueryClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public abstract partial class SelectOrGroupClauseSyntax : CSharpSyntaxNode
  {
    internal SelectOrGroupClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class QueryExpressionSyntax : ExpressionSyntax
  {
    private FromClauseSyntax fromClause;
    private QueryBodySyntax body;

    internal QueryExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public FromClauseSyntax FromClause 
    {
        get
        {
            return this.GetRedAtZero(ref this.fromClause);
        }
    }

    public QueryBodySyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.fromClause);
            case 1: return this.GetRed(ref this.body, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromClause;
            case 1: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryExpression(this);
    }

    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
        if (fromClause != this.FromClause || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryExpression(fromClause, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryExpressionSyntax WithFromClause(FromClauseSyntax fromClause)
    {
        return this.Update(fromClause, this.Body);
    }

    public QueryExpressionSyntax WithBody(QueryBodySyntax body)
    {
        return this.Update(this.FromClause, body);
    }

    public QueryExpressionSyntax AddBodyClauses(params QueryClauseSyntax[] items)
    {
        return this.WithBody(this.Body.WithClauses(this.Body.Clauses.AddRange(items)));
    }
  }

  public sealed partial class QueryBodySyntax : CSharpSyntaxNode
  {
    private SyntaxNode clauses;
    private SelectOrGroupClauseSyntax selectOrGroup;
    private QueryContinuationSyntax continuation;

    internal QueryBodySyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxList<QueryClauseSyntax> Clauses 
    {
        get
        {
            return new SyntaxList<QueryClauseSyntax>(this.GetRed(ref this.clauses, 0));
        }
    }

    public SelectOrGroupClauseSyntax SelectOrGroup 
    {
        get
        {
            return this.GetRed(ref this.selectOrGroup, 1);
        }
    }

    public QueryContinuationSyntax Continuation 
    {
        get
        {
            return this.GetRed(ref this.continuation, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.clauses);
            case 1: return this.GetRed(ref this.selectOrGroup, 1);
            case 2: return this.GetRed(ref this.continuation, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.clauses;
            case 1: return this.selectOrGroup;
            case 2: return this.continuation;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryBody(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryBody(this);
    }

    public QueryBodySyntax Update(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
        if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation)
        {
            var newNode = SyntaxFactory.QueryBody(clauses, selectOrGroup, continuation);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryBodySyntax WithClauses(SyntaxList<QueryClauseSyntax> clauses)
    {
        return this.Update(clauses, this.SelectOrGroup, this.Continuation);
    }

    public QueryBodySyntax WithSelectOrGroup(SelectOrGroupClauseSyntax selectOrGroup)
    {
        return this.Update(this.Clauses, selectOrGroup, this.Continuation);
    }

    public QueryBodySyntax WithContinuation(QueryContinuationSyntax continuation)
    {
        return this.Update(this.Clauses, this.SelectOrGroup, continuation);
    }

    public QueryBodySyntax AddClauses(params QueryClauseSyntax[] items)
    {
        return this.WithClauses(this.Clauses.AddRange(items));
    }
  }

  public sealed partial class FromClauseSyntax : QueryClauseSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax expression;

    internal FromClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken FromKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.FromClauseSyntax)this.Green).fromKeyword, this.Position, 0); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.FromClauseSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.FromClauseSyntax)this.Green).inKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 4: return this.GetRed(ref this.expression, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 4: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFromClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFromClause(this);
    }

    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
        if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.FromClause(fromKeyword, type, identifier, inKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FromClauseSyntax WithFromKeyword(SyntaxToken fromKeyword)
    {
        return this.Update(fromKeyword, this.Type, this.Identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.FromKeyword, type, this.Identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.FromKeyword, this.Type, identifier, this.InKeyword, this.Expression);
    }

    public FromClauseSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.FromKeyword, this.Type, this.Identifier, inKeyword, this.Expression);
    }

    public FromClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.FromKeyword, this.Type, this.Identifier, this.InKeyword, expression);
    }
  }

  public sealed partial class LetClauseSyntax : QueryClauseSyntax
  {
    private ExpressionSyntax expression;

    internal LetClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LetKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LetClauseSyntax)this.Green).letKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LetClauseSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LetClauseSyntax)this.Green).equalsToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 3: return this.GetRed(ref this.expression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 3: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLetClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLetClause(this);
    }

    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
        if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.LetClause(letKeyword, identifier, equalsToken, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LetClauseSyntax WithLetKeyword(SyntaxToken letKeyword)
    {
        return this.Update(letKeyword, this.Identifier, this.EqualsToken, this.Expression);
    }

    public LetClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.LetKeyword, identifier, this.EqualsToken, this.Expression);
    }

    public LetClauseSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.LetKeyword, this.Identifier, equalsToken, this.Expression);
    }

    public LetClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.LetKeyword, this.Identifier, this.EqualsToken, expression);
    }
  }

  public sealed partial class JoinClauseSyntax : QueryClauseSyntax
  {
    private TypeSyntax type;
    private ExpressionSyntax inExpression;
    private ExpressionSyntax leftExpression;
    private ExpressionSyntax rightExpression;
    private JoinIntoClauseSyntax into;

    internal JoinClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken JoinKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).joinKeyword, this.Position, 0); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).inKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax InExpression 
    {
        get
        {
            return this.GetRed(ref this.inExpression, 4);
        }
    }

    public SyntaxToken OnKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).onKeyword, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public ExpressionSyntax LeftExpression 
    {
        get
        {
            return this.GetRed(ref this.leftExpression, 6);
        }
    }

    public SyntaxToken EqualsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.JoinClauseSyntax)this.Green).equalsKeyword, this.GetChildPosition(7), this.GetChildIndex(7)); }
    }

    public ExpressionSyntax RightExpression 
    {
        get
        {
            return this.GetRed(ref this.rightExpression, 8);
        }
    }

    public JoinIntoClauseSyntax Into 
    {
        get
        {
            return this.GetRed(ref this.into, 9);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            case 4: return this.GetRed(ref this.inExpression, 4);
            case 6: return this.GetRed(ref this.leftExpression, 6);
            case 8: return this.GetRed(ref this.rightExpression, 8);
            case 9: return this.GetRed(ref this.into, 9);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            case 4: return this.inExpression;
            case 6: return this.leftExpression;
            case 8: return this.rightExpression;
            case 9: return this.into;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitJoinClause(this);
    }

    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
        if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into)
        {
            var newNode = SyntaxFactory.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public JoinClauseSyntax WithJoinKeyword(SyntaxToken joinKeyword)
    {
        return this.Update(joinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.JoinKeyword, type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.JoinKeyword, this.Type, identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, inKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithInExpression(ExpressionSyntax inExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, inExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithOnKeyword(SyntaxToken onKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, onKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithLeftExpression(ExpressionSyntax leftExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, leftExpression, this.EqualsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithEqualsKeyword(SyntaxToken equalsKeyword)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, equalsKeyword, this.RightExpression, this.Into);
    }

    public JoinClauseSyntax WithRightExpression(ExpressionSyntax rightExpression)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, rightExpression, this.Into);
    }

    public JoinClauseSyntax WithInto(JoinIntoClauseSyntax into)
    {
        return this.Update(this.JoinKeyword, this.Type, this.Identifier, this.InKeyword, this.InExpression, this.OnKeyword, this.LeftExpression, this.EqualsKeyword, this.RightExpression, into);
    }
  }

  public sealed partial class JoinIntoClauseSyntax : CSharpSyntaxNode
  {
    internal JoinIntoClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken IntoKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.JoinIntoClauseSyntax)this.Green).intoKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.JoinIntoClauseSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinIntoClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitJoinIntoClause(this);
    }

    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.JoinIntoClause(intoKeyword, identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public JoinIntoClauseSyntax WithIntoKeyword(SyntaxToken intoKeyword)
    {
        return this.Update(intoKeyword, this.Identifier);
    }

    public JoinIntoClauseSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.IntoKeyword, identifier);
    }
  }

  public sealed partial class WhereClauseSyntax : QueryClauseSyntax
  {
    private ExpressionSyntax condition;

    internal WhereClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhereKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.WhereClauseSyntax)this.Green).whereKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhereClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhereClause(this);
    }

    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
        if (whereKeyword != this.WhereKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhereClause(whereKeyword, condition);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WhereClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)
    {
        return this.Update(whereKeyword, this.Condition);
    }

    public WhereClauseSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.WhereKeyword, condition);
    }
  }

  public sealed partial class OrderByClauseSyntax : QueryClauseSyntax
  {
    private SyntaxNode orderings;

    internal OrderByClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OrderByKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OrderByClauseSyntax)this.Green).orderByKeyword, this.Position, 0); }
    }

    public SeparatedSyntaxList<OrderingSyntax> Orderings 
    {
        get
        {
            var red = this.GetRed(ref this.orderings, 1);
            if (red != null)
                return new SeparatedSyntaxList<OrderingSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<OrderingSyntax>);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.orderings, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.orderings;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrderByClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOrderByClause(this);
    }

    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings)
        {
            var newNode = SyntaxFactory.OrderByClause(orderByKeyword, orderings);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OrderByClauseSyntax WithOrderByKeyword(SyntaxToken orderByKeyword)
    {
        return this.Update(orderByKeyword, this.Orderings);
    }

    public OrderByClauseSyntax WithOrderings(SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        return this.Update(this.OrderByKeyword, orderings);
    }

    public OrderByClauseSyntax AddOrderings(params OrderingSyntax[] items)
    {
        return this.WithOrderings(this.Orderings.AddRange(items));
    }
  }

  public sealed partial class OrderingSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax expression;

    internal OrderingSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    public SyntaxToken AscendingOrDescendingKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OrderingSyntax)this.Green).ascendingOrDescendingKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrdering(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOrdering(this);
    }

    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
        if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword)
        {
            var newNode = SyntaxFactory.Ordering(this.Kind(), expression, ascendingOrDescendingKeyword);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OrderingSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.AscendingOrDescendingKeyword);
    }

    public OrderingSyntax WithAscendingOrDescendingKeyword(SyntaxToken ascendingOrDescendingKeyword)
    {
        return this.Update(this.Expression, ascendingOrDescendingKeyword);
    }
  }

  public sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
  {
    private ExpressionSyntax expression;

    internal SelectClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken SelectKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SelectClauseSyntax)this.Green).selectKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSelectClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSelectClause(this);
    }

    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
        if (selectKeyword != this.SelectKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.SelectClause(selectKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SelectClauseSyntax WithSelectKeyword(SyntaxToken selectKeyword)
    {
        return this.Update(selectKeyword, this.Expression);
    }

    public SelectClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.SelectKeyword, expression);
    }
  }

  public sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
  {
    private ExpressionSyntax groupExpression;
    private ExpressionSyntax byExpression;

    internal GroupClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken GroupKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.GroupClauseSyntax)this.Green).groupKeyword, this.Position, 0); }
    }

    public ExpressionSyntax GroupExpression 
    {
        get
        {
            return this.GetRed(ref this.groupExpression, 1);
        }
    }

    public SyntaxToken ByKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.GroupClauseSyntax)this.Green).byKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExpressionSyntax ByExpression 
    {
        get
        {
            return this.GetRed(ref this.byExpression, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.groupExpression, 1);
            case 3: return this.GetRed(ref this.byExpression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.groupExpression;
            case 3: return this.byExpression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGroupClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGroupClause(this);
    }

    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
        if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression)
        {
            var newNode = SyntaxFactory.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GroupClauseSyntax WithGroupKeyword(SyntaxToken groupKeyword)
    {
        return this.Update(groupKeyword, this.GroupExpression, this.ByKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithGroupExpression(ExpressionSyntax groupExpression)
    {
        return this.Update(this.GroupKeyword, groupExpression, this.ByKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithByKeyword(SyntaxToken byKeyword)
    {
        return this.Update(this.GroupKeyword, this.GroupExpression, byKeyword, this.ByExpression);
    }

    public GroupClauseSyntax WithByExpression(ExpressionSyntax byExpression)
    {
        return this.Update(this.GroupKeyword, this.GroupExpression, this.ByKeyword, byExpression);
    }
  }

  public sealed partial class QueryContinuationSyntax : CSharpSyntaxNode
  {
    private QueryBodySyntax body;

    internal QueryContinuationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken IntoKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.QueryContinuationSyntax)this.Green).intoKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.QueryContinuationSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public QueryBodySyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.body, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.body;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryContinuation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryContinuation(this);
    }

    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryContinuation(intoKeyword, identifier, body);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QueryContinuationSyntax WithIntoKeyword(SyntaxToken intoKeyword)
    {
        return this.Update(intoKeyword, this.Identifier, this.Body);
    }

    public QueryContinuationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.IntoKeyword, identifier, this.Body);
    }

    public QueryContinuationSyntax WithBody(QueryBodySyntax body)
    {
        return this.Update(this.IntoKeyword, this.Identifier, body);
    }

    public QueryContinuationSyntax AddBodyClauses(params QueryClauseSyntax[] items)
    {
        return this.WithBody(this.Body.WithClauses(this.Body.Clauses.AddRange(items)));
    }
  }

  /// <summary>Class which represents a placeholder in an array size list.</summary>
  public sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
  {
    internal OmittedArraySizeExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the omitted array size expression.</summary>
    public SyntaxToken OmittedArraySizeExpressionToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OmittedArraySizeExpressionSyntax)this.Green).omittedArraySizeExpressionToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedArraySizeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOmittedArraySizeExpression(this);
    }

    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)
    {
        if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
        {
            var newNode = SyntaxFactory.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OmittedArraySizeExpressionSyntax WithOmittedArraySizeExpressionToken(SyntaxToken omittedArraySizeExpressionToken)
    {
        return this.Update(omittedArraySizeExpressionToken);
    }
  }

  public sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
  {
    private SyntaxNode contents;

    internal InterpolatedStringExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>The first part of an interpolated string, $" or $@"</summary>
    public SyntaxToken StringStartToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax)this.Green).stringStartToken, this.Position, 0); }
    }

    /// <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
    public SyntaxList<InterpolatedStringContentSyntax> Contents 
    {
        get
        {
            return new SyntaxList<InterpolatedStringContentSyntax>(this.GetRed(ref this.contents, 1));
        }
    }

    /// <summary>The closing quote of the interpolated string.</summary>
    public SyntaxToken StringEndToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax)this.Green).stringEndToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.contents, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.contents;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolatedStringExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolatedStringExpression(this);
    }

    public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
        if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, stringEndToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolatedStringExpressionSyntax WithStringStartToken(SyntaxToken stringStartToken)
    {
        return this.Update(stringStartToken, this.Contents, this.StringEndToken);
    }

    public InterpolatedStringExpressionSyntax WithContents(SyntaxList<InterpolatedStringContentSyntax> contents)
    {
        return this.Update(this.StringStartToken, contents, this.StringEndToken);
    }

    public InterpolatedStringExpressionSyntax WithStringEndToken(SyntaxToken stringEndToken)
    {
        return this.Update(this.StringStartToken, this.Contents, stringEndToken);
    }

    public InterpolatedStringExpressionSyntax AddContents(params InterpolatedStringContentSyntax[] items)
    {
        return this.WithContents(this.Contents.AddRange(items));
    }
  }

  /// <summary>Class which represents a simple pattern-matching expression using the "is" keyword.</summary>
  public sealed partial class IsPatternExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;
    private PatternSyntax pattern;

    internal IsPatternExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    public SyntaxToken IsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IsPatternExpressionSyntax)this.Green).isKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
    public PatternSyntax Pattern 
    {
        get
        {
            return this.GetRed(ref this.pattern, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            case 2: return this.GetRed(ref this.pattern, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 2: return this.pattern;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIsPatternExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIsPatternExpression(this);
    }

    public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
        if (expression != this.Expression || isKeyword != this.IsKeyword || pattern != this.Pattern)
        {
            var newNode = SyntaxFactory.IsPatternExpression(expression, isKeyword, pattern);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IsPatternExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.IsKeyword, this.Pattern);
    }

    public IsPatternExpressionSyntax WithIsKeyword(SyntaxToken isKeyword)
    {
        return this.Update(this.Expression, isKeyword, this.Pattern);
    }

    public IsPatternExpressionSyntax WithPattern(PatternSyntax pattern)
    {
        return this.Update(this.Expression, this.IsKeyword, pattern);
    }
  }

  public sealed partial class ThrowExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax expression;

    internal ThrowExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ThrowKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ThrowExpressionSyntax)this.Green).throwKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThrowExpression(this);
    }

    public ThrowExpressionSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.ThrowExpression(throwKeyword, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ThrowExpressionSyntax WithThrowKeyword(SyntaxToken throwKeyword)
    {
        return this.Update(throwKeyword, this.Expression);
    }

    public ThrowExpressionSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ThrowKeyword, expression);
    }
  }

  public sealed partial class WhenClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax condition;

    internal WhenClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhenKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.WhenClauseSyntax)this.Green).whenKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhenClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhenClause(this);
    }

    public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
        if (whenKeyword != this.WhenKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhenClause(whenKeyword, condition);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WhenClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword)
    {
        return this.Update(whenKeyword, this.Condition);
    }

    public WhenClauseSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.WhenKeyword, condition);
    }
  }

  public abstract partial class PatternSyntax : CSharpSyntaxNode
  {
    internal PatternSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class DiscardPatternSyntax : PatternSyntax
  {
    internal DiscardPatternSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken UnderscoreToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DiscardPatternSyntax)this.Green).underscoreToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDiscardPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDiscardPattern(this);
    }

    public DiscardPatternSyntax Update(SyntaxToken underscoreToken)
    {
        if (underscoreToken != this.UnderscoreToken)
        {
            var newNode = SyntaxFactory.DiscardPattern(underscoreToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DiscardPatternSyntax WithUnderscoreToken(SyntaxToken underscoreToken)
    {
        return this.Update(underscoreToken);
    }
  }

  public sealed partial class DeclarationPatternSyntax : PatternSyntax
  {
    private TypeSyntax type;
    private VariableDesignationSyntax designation;

    internal DeclarationPatternSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    public VariableDesignationSyntax Designation 
    {
        get
        {
            return this.GetRed(ref this.designation, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            case 1: return this.GetRed(ref this.designation, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.designation;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDeclarationPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDeclarationPattern(this);
    }

    public DeclarationPatternSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)
    {
        if (type != this.Type || designation != this.Designation)
        {
            var newNode = SyntaxFactory.DeclarationPattern(type, designation);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DeclarationPatternSyntax WithType(TypeSyntax type)
    {
        return this.Update(type, this.Designation);
    }

    public DeclarationPatternSyntax WithDesignation(VariableDesignationSyntax designation)
    {
        return this.Update(this.Type, designation);
    }
  }

  public sealed partial class VarPatternSyntax : PatternSyntax
  {
    private VariableDesignationSyntax designation;

    internal VarPatternSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken VarKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.VarPatternSyntax)this.Green).varKeyword, this.Position, 0); }
    }

    public VariableDesignationSyntax Designation 
    {
        get
        {
            return this.GetRed(ref this.designation, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.designation, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.designation;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVarPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVarPattern(this);
    }

    public VarPatternSyntax Update(SyntaxToken varKeyword, VariableDesignationSyntax designation)
    {
        if (varKeyword != this.VarKeyword || designation != this.Designation)
        {
            var newNode = SyntaxFactory.VarPattern(varKeyword, designation);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public VarPatternSyntax WithVarKeyword(SyntaxToken varKeyword)
    {
        return this.Update(varKeyword, this.Designation);
    }

    public VarPatternSyntax WithDesignation(VariableDesignationSyntax designation)
    {
        return this.Update(this.VarKeyword, designation);
    }
  }

  public sealed partial class RecursivePatternSyntax : PatternSyntax
  {
    private TypeSyntax type;
    private PositionalPatternClauseSyntax positionalPatternClause;
    private PropertyPatternClauseSyntax propertyPatternClause;
    private VariableDesignationSyntax designation;

    internal RecursivePatternSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    public PositionalPatternClauseSyntax PositionalPatternClause 
    {
        get
        {
            return this.GetRed(ref this.positionalPatternClause, 1);
        }
    }

    public PropertyPatternClauseSyntax PropertyPatternClause 
    {
        get
        {
            return this.GetRed(ref this.propertyPatternClause, 2);
        }
    }

    public VariableDesignationSyntax Designation 
    {
        get
        {
            return this.GetRed(ref this.designation, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            case 1: return this.GetRed(ref this.positionalPatternClause, 1);
            case 2: return this.GetRed(ref this.propertyPatternClause, 2);
            case 3: return this.GetRed(ref this.designation, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.positionalPatternClause;
            case 2: return this.propertyPatternClause;
            case 3: return this.designation;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRecursivePattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRecursivePattern(this);
    }

    public RecursivePatternSyntax Update(TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
    {
        if (type != this.Type || positionalPatternClause != this.PositionalPatternClause || propertyPatternClause != this.PropertyPatternClause || designation != this.Designation)
        {
            var newNode = SyntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause, designation);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public RecursivePatternSyntax WithType(TypeSyntax type)
    {
        return this.Update(type, this.PositionalPatternClause, this.PropertyPatternClause, this.Designation);
    }

    public RecursivePatternSyntax WithPositionalPatternClause(PositionalPatternClauseSyntax positionalPatternClause)
    {
        return this.Update(this.Type, positionalPatternClause, this.PropertyPatternClause, this.Designation);
    }

    public RecursivePatternSyntax WithPropertyPatternClause(PropertyPatternClauseSyntax propertyPatternClause)
    {
        return this.Update(this.Type, this.PositionalPatternClause, propertyPatternClause, this.Designation);
    }

    public RecursivePatternSyntax WithDesignation(VariableDesignationSyntax designation)
    {
        return this.Update(this.Type, this.PositionalPatternClause, this.PropertyPatternClause, designation);
    }

    public RecursivePatternSyntax AddPositionalPatternClauseSubpatterns(params SubpatternSyntax[] items)
    {
        var positionalPatternClause = this.PositionalPatternClause ?? SyntaxFactory.PositionalPatternClause();
        return this.WithPositionalPatternClause(positionalPatternClause.WithSubpatterns(positionalPatternClause.Subpatterns.AddRange(items)));
    }

    public RecursivePatternSyntax AddPropertyPatternClauseSubpatterns(params SubpatternSyntax[] items)
    {
        var propertyPatternClause = this.PropertyPatternClause ?? SyntaxFactory.PropertyPatternClause();
        return this.WithPropertyPatternClause(propertyPatternClause.WithSubpatterns(propertyPatternClause.Subpatterns.AddRange(items)));
    }
  }

  public sealed partial class PositionalPatternClauseSyntax : CSharpSyntaxNode
  {
    private SyntaxNode subpatterns;

    internal PositionalPatternClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PositionalPatternClauseSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public SeparatedSyntaxList<SubpatternSyntax> Subpatterns 
    {
        get
        {
            var red = this.GetRed(ref this.subpatterns, 1);
            if (red != null)
                return new SeparatedSyntaxList<SubpatternSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<SubpatternSyntax>);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PositionalPatternClauseSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.subpatterns, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.subpatterns;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPositionalPatternClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPositionalPatternClause(this);
    }

    public PositionalPatternClauseSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || subpatterns != this.Subpatterns || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.PositionalPatternClause(openParenToken, subpatterns, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PositionalPatternClauseSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Subpatterns, this.CloseParenToken);
    }

    public PositionalPatternClauseSyntax WithSubpatterns(SeparatedSyntaxList<SubpatternSyntax> subpatterns)
    {
        return this.Update(this.OpenParenToken, subpatterns, this.CloseParenToken);
    }

    public PositionalPatternClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Subpatterns, closeParenToken);
    }

    public PositionalPatternClauseSyntax AddSubpatterns(params SubpatternSyntax[] items)
    {
        return this.WithSubpatterns(this.Subpatterns.AddRange(items));
    }
  }

  public sealed partial class PropertyPatternClauseSyntax : CSharpSyntaxNode
  {
    private SyntaxNode subpatterns;

    internal PropertyPatternClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PropertyPatternClauseSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    public SeparatedSyntaxList<SubpatternSyntax> Subpatterns 
    {
        get
        {
            var red = this.GetRed(ref this.subpatterns, 1);
            if (red != null)
                return new SeparatedSyntaxList<SubpatternSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<SubpatternSyntax>);
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PropertyPatternClauseSyntax)this.Green).closeBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.subpatterns, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.subpatterns;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPropertyPatternClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPropertyPatternClause(this);
    }

    public PropertyPatternClauseSyntax Update(SyntaxToken openBraceToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || subpatterns != this.Subpatterns || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.PropertyPatternClause(openBraceToken, subpatterns, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public PropertyPatternClauseSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Subpatterns, this.CloseBraceToken);
    }

    public PropertyPatternClauseSyntax WithSubpatterns(SeparatedSyntaxList<SubpatternSyntax> subpatterns)
    {
        return this.Update(this.OpenBraceToken, subpatterns, this.CloseBraceToken);
    }

    public PropertyPatternClauseSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Subpatterns, closeBraceToken);
    }

    public PropertyPatternClauseSyntax AddSubpatterns(params SubpatternSyntax[] items)
    {
        return this.WithSubpatterns(this.Subpatterns.AddRange(items));
    }
  }

  public sealed partial class SubpatternSyntax : CSharpSyntaxNode
  {
    private NameColonSyntax nameColon;
    private PatternSyntax pattern;

    internal SubpatternSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public NameColonSyntax NameColon 
    {
        get
        {
            return this.GetRedAtZero(ref this.nameColon);
        }
    }

    public PatternSyntax Pattern 
    {
        get
        {
            return this.GetRed(ref this.pattern, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.nameColon);
            case 1: return this.GetRed(ref this.pattern, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 1: return this.pattern;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSubpattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSubpattern(this);
    }

    public SubpatternSyntax Update(NameColonSyntax nameColon, PatternSyntax pattern)
    {
        if (nameColon != this.NameColon || pattern != this.Pattern)
        {
            var newNode = SyntaxFactory.Subpattern(nameColon, pattern);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SubpatternSyntax WithNameColon(NameColonSyntax nameColon)
    {
        return this.Update(nameColon, this.Pattern);
    }

    public SubpatternSyntax WithPattern(PatternSyntax pattern)
    {
        return this.Update(this.NameColon, pattern);
    }
  }

  public sealed partial class ConstantPatternSyntax : PatternSyntax
  {
    private ExpressionSyntax expression;

    internal ConstantPatternSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>ExpressionSyntax node representing the constant expression.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstantPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstantPattern(this);
    }

    public ConstantPatternSyntax Update(ExpressionSyntax expression)
    {
        if (expression != this.Expression)
        {
            var newNode = SyntaxFactory.ConstantPattern(expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstantPatternSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression);
    }
  }

  public abstract partial class InterpolatedStringContentSyntax : CSharpSyntaxNode
  {
    internal InterpolatedStringContentSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
  {
    internal InterpolatedStringTextSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>The text contents of a part of the interpolated string.</summary>
    public SyntaxToken TextToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterpolatedStringTextSyntax)this.Green).textToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolatedStringText(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolatedStringText(this);
    }

    public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
    {
        if (textToken != this.TextToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringText(textToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolatedStringTextSyntax WithTextToken(SyntaxToken textToken)
    {
        return this.Update(textToken);
    }
  }

  public sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
  {
    private ExpressionSyntax expression;
    private InterpolationAlignmentClauseSyntax alignmentClause;
    private InterpolationFormatClauseSyntax formatClause;

    internal InterpolationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterpolationSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    public InterpolationAlignmentClauseSyntax AlignmentClause 
    {
        get
        {
            return this.GetRed(ref this.alignmentClause, 2);
        }
    }

    public InterpolationFormatClauseSyntax FormatClause 
    {
        get
        {
            return this.GetRed(ref this.formatClause, 3);
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterpolationSyntax)this.Green).closeBraceToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            case 2: return this.GetRed(ref this.alignmentClause, 2);
            case 3: return this.GetRed(ref this.formatClause, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            case 2: return this.alignmentClause;
            case 3: return this.formatClause;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolation(this);
    }

    public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expression != this.Expression || alignmentClause != this.AlignmentClause || formatClause != this.FormatClause || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Expression, this.AlignmentClause, this.FormatClause, this.CloseBraceToken);
    }

    public InterpolationSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.OpenBraceToken, expression, this.AlignmentClause, this.FormatClause, this.CloseBraceToken);
    }

    public InterpolationSyntax WithAlignmentClause(InterpolationAlignmentClauseSyntax alignmentClause)
    {
        return this.Update(this.OpenBraceToken, this.Expression, alignmentClause, this.FormatClause, this.CloseBraceToken);
    }

    public InterpolationSyntax WithFormatClause(InterpolationFormatClauseSyntax formatClause)
    {
        return this.Update(this.OpenBraceToken, this.Expression, this.AlignmentClause, formatClause, this.CloseBraceToken);
    }

    public InterpolationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Expression, this.AlignmentClause, this.FormatClause, closeBraceToken);
    }
  }

  public sealed partial class InterpolationAlignmentClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax value;

    internal InterpolationAlignmentClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken CommaToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax)this.Green).commaToken, this.Position, 0); }
    }

    public ExpressionSyntax Value 
    {
        get
        {
            return this.GetRed(ref this.value, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.value, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolationAlignmentClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolationAlignmentClause(this);
    }

    public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value)
    {
        if (commaToken != this.CommaToken || value != this.Value)
        {
            var newNode = SyntaxFactory.InterpolationAlignmentClause(commaToken, value);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolationAlignmentClauseSyntax WithCommaToken(SyntaxToken commaToken)
    {
        return this.Update(commaToken, this.Value);
    }

    public InterpolationAlignmentClauseSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.CommaToken, value);
    }
  }

  public sealed partial class InterpolationFormatClauseSyntax : CSharpSyntaxNode
  {
    internal InterpolationFormatClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterpolationFormatClauseSyntax)this.Green).colonToken, this.Position, 0); }
    }

    /// <summary>The text contents of the format specifier for an interpolation.</summary>
    public SyntaxToken FormatStringToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterpolationFormatClauseSyntax)this.Green).formatStringToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolationFormatClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolationFormatClause(this);
    }

    public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
        if (colonToken != this.ColonToken || formatStringToken != this.FormatStringToken)
        {
            var newNode = SyntaxFactory.InterpolationFormatClause(colonToken, formatStringToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InterpolationFormatClauseSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(colonToken, this.FormatStringToken);
    }

    public InterpolationFormatClauseSyntax WithFormatStringToken(SyntaxToken formatStringToken)
    {
        return this.Update(this.ColonToken, formatStringToken);
    }
  }

  public sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
  {
    private StatementSyntax statement;

    internal GlobalStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRedAtZero(ref this.statement);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.statement);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGlobalStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGlobalStatement(this);
    }

    public GlobalStatementSyntax Update(StatementSyntax statement)
    {
        if (statement != this.Statement)
        {
            var newNode = SyntaxFactory.GlobalStatement(statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GlobalStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(statement);
    }
  }

  /// <summary>Represents the base class for all statements syntax classes.</summary>
  public abstract partial class StatementSyntax : CSharpSyntaxNode
  {
    internal StatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class BlockSyntax : StatementSyntax
  {
    private SyntaxNode statements;

    internal BlockSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BlockSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    public SyntaxList<StatementSyntax> Statements 
    {
        get
        {
            return new SyntaxList<StatementSyntax>(this.GetRed(ref this.statements, 1));
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BlockSyntax)this.Green).closeBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statements, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statements;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBlock(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBlock(this);
    }

    public BlockSyntax Update(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Block(openBraceToken, statements, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BlockSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Statements, this.CloseBraceToken);
    }

    public BlockSyntax WithStatements(SyntaxList<StatementSyntax> statements)
    {
        return this.Update(this.OpenBraceToken, statements, this.CloseBraceToken);
    }

    public BlockSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Statements, closeBraceToken);
    }

    public BlockSyntax AddStatements(params StatementSyntax[] items)
    {
        return this.WithStatements(this.Statements.AddRange(items));
    }
  }

  public sealed partial class LocalFunctionStatementSyntax : StatementSyntax
  {
    private TypeSyntax returnType;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private SyntaxNode constraintClauses;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal LocalFunctionStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    public TypeSyntax ReturnType 
    {
        get
        {
            return this.GetRed(ref this.returnType, 1);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LocalFunctionStatementSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 3);
        }
    }

    public ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 4);
        }
    }

    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 5));
        }
    }

    public BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 6);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 7);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LocalFunctionStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(8), this.GetChildIndex(8));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.returnType, 1);
            case 3: return this.GetRed(ref this.typeParameterList, 3);
            case 4: return this.GetRed(ref this.parameterList, 4);
            case 5: return this.GetRed(ref this.constraintClauses, 5);
            case 6: return this.GetRed(ref this.body, 6);
            case 7: return this.GetRed(ref this.expressionBody, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.returnType;
            case 3: return this.typeParameterList;
            case 4: return this.parameterList;
            case 5: return this.constraintClauses;
            case 6: return this.body;
            case 7: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalFunctionStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLocalFunctionStatement(this);
    }

    public LocalFunctionStatementSyntax Update(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken eosToken)
    {
        if (modifiers != this.Modifiers || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.LocalFunctionStatement(modifiers, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LocalFunctionStatementSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public LocalFunctionStatementSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.Modifiers, returnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public LocalFunctionStatementSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.Modifiers, this.ReturnType, identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public LocalFunctionStatementSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.Modifiers, this.ReturnType, this.Identifier, typeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public LocalFunctionStatementSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, parameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public LocalFunctionStatementSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, constraintClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public LocalFunctionStatementSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, body, this.ExpressionBody, this.EosToken);
    }

    public LocalFunctionStatementSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, expressionBody, this.EosToken);
    }

    public LocalFunctionStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.Modifiers, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.Body, this.ExpressionBody, eosToken);
    }

    public LocalFunctionStatementSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public LocalFunctionStatementSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }

    public LocalFunctionStatementSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public LocalFunctionStatementSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }

    public LocalFunctionStatementSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  public sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;

    internal LocalDeclarationStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken AwaitKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LocalDeclarationStatementSyntax)this.Green).awaitKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    public SyntaxToken UsingKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LocalDeclarationStatementSyntax)this.Green).usingKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 2);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LocalDeclarationStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.declaration, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalDeclarationStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLocalDeclarationStatement(this);
    }

    public LocalDeclarationStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, VariableDeclarationSyntax declaration, SyntaxToken eosToken)
    {
        if (awaitKeyword != this.AwaitKeyword || usingKeyword != this.UsingKeyword || declaration != this.Declaration || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.LocalDeclarationStatement(awaitKeyword, usingKeyword, declaration, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LocalDeclarationStatementSyntax WithAwaitKeyword(SyntaxToken awaitKeyword)
    {
        return this.Update(awaitKeyword, this.UsingKeyword, this.Declaration, this.EosToken);
    }

    public LocalDeclarationStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword)
    {
        return this.Update(this.AwaitKeyword, usingKeyword, this.Declaration, this.EosToken);
    }

    public LocalDeclarationStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.AwaitKeyword, this.UsingKeyword, declaration, this.EosToken);
    }

    public LocalDeclarationStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AwaitKeyword, this.UsingKeyword, this.Declaration, eosToken);
    }
  }

  public sealed partial class VariableDeclarationSyntax : CSharpSyntaxNode
  {
    private TypeSyntax type;
    private EqualsValueClauseSyntax initializer;

    internal VariableDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the variable keyword.</summary>
    public SyntaxToken VariableKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.VariableDeclarationSyntax)this.Green).variableKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.VariableDeclarationSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.VariableDeclarationSyntax)this.Green).colonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 3);
        }
    }

    public EqualsValueClauseSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 3: return this.GetRed(ref this.type, 3);
            case 4: return this.GetRed(ref this.initializer, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 3: return this.type;
            case 4: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclaration(this);
    }

    public VariableDeclarationSyntax Update(SyntaxToken variableKeyword, SyntaxToken identifier, SyntaxToken colonToken, TypeSyntax type, EqualsValueClauseSyntax initializer)
    {
        if (variableKeyword != this.VariableKeyword || identifier != this.Identifier || colonToken != this.ColonToken || type != this.Type || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.VariableDeclaration(variableKeyword, identifier, colonToken, type, initializer);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public VariableDeclarationSyntax WithVariableKeyword(SyntaxToken variableKeyword)
    {
        return this.Update(variableKeyword, this.Identifier, this.ColonToken, this.Type, this.Initializer);
    }

    public VariableDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.VariableKeyword, identifier, this.ColonToken, this.Type, this.Initializer);
    }

    public VariableDeclarationSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.VariableKeyword, this.Identifier, colonToken, this.Type, this.Initializer);
    }

    public VariableDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.VariableKeyword, this.Identifier, this.ColonToken, type, this.Initializer);
    }

    public VariableDeclarationSyntax WithInitializer(EqualsValueClauseSyntax initializer)
    {
        return this.Update(this.VariableKeyword, this.Identifier, this.ColonToken, this.Type, initializer);
    }
  }

  public sealed partial class EqualsValueClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax value;

    internal EqualsValueClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EqualsValueClauseSyntax)this.Green).equalsToken, this.Position, 0); }
    }

    public ExpressionSyntax Value 
    {
        get
        {
            return this.GetRed(ref this.value, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.value, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEqualsValueClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEqualsValueClause(this);
    }

    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value)
    {
        if (equalsToken != this.EqualsToken || value != this.Value)
        {
            var newNode = SyntaxFactory.EqualsValueClause(equalsToken, value);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EqualsValueClauseSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(equalsToken, this.Value);
    }

    public EqualsValueClauseSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.EqualsToken, value);
    }
  }

  public abstract partial class VariableDesignationSyntax : CSharpSyntaxNode
  {
    internal VariableDesignationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class SingleVariableDesignationSyntax : VariableDesignationSyntax
  {
    internal SingleVariableDesignationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SingleVariableDesignationSyntax)this.Green).identifier, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSingleVariableDesignation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSingleVariableDesignation(this);
    }

    public SingleVariableDesignationSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.SingleVariableDesignation(identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SingleVariableDesignationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier);
    }
  }

  public sealed partial class DiscardDesignationSyntax : VariableDesignationSyntax
  {
    internal DiscardDesignationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken UnderscoreToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DiscardDesignationSyntax)this.Green).underscoreToken, this.Position, 0); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDiscardDesignation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDiscardDesignation(this);
    }

    public DiscardDesignationSyntax Update(SyntaxToken underscoreToken)
    {
        if (underscoreToken != this.UnderscoreToken)
        {
            var newNode = SyntaxFactory.DiscardDesignation(underscoreToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DiscardDesignationSyntax WithUnderscoreToken(SyntaxToken underscoreToken)
    {
        return this.Update(underscoreToken);
    }
  }

  public sealed partial class ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax
  {
    private SyntaxNode variables;

    internal ParenthesizedVariableDesignationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParenthesizedVariableDesignationSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public SeparatedSyntaxList<VariableDesignationSyntax> Variables 
    {
        get
        {
            var red = this.GetRed(ref this.variables, 1);
            if (red != null)
                return new SeparatedSyntaxList<VariableDesignationSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<VariableDesignationSyntax>);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParenthesizedVariableDesignationSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.variables, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.variables;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedVariableDesignation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedVariableDesignation(this);
    }

    public ParenthesizedVariableDesignationSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || variables != this.Variables || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParenthesizedVariableDesignation(openParenToken, variables, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParenthesizedVariableDesignationSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Variables, this.CloseParenToken);
    }

    public ParenthesizedVariableDesignationSyntax WithVariables(SeparatedSyntaxList<VariableDesignationSyntax> variables)
    {
        return this.Update(this.OpenParenToken, variables, this.CloseParenToken);
    }

    public ParenthesizedVariableDesignationSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Variables, closeParenToken);
    }

    public ParenthesizedVariableDesignationSyntax AddVariables(params VariableDesignationSyntax[] items)
    {
        return this.WithVariables(this.Variables.AddRange(items));
    }
  }

  public sealed partial class ExpressionStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ExpressionStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRedAtZero(ref this.expression);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ExpressionStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.expression);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExpressionStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExpressionStatement(this);
    }

    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken eosToken)
    {
        if (expression != this.Expression || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ExpressionStatement(expression, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExpressionStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(expression, this.EosToken);
    }

    public ExpressionStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.Expression, eosToken);
    }
  }

  public sealed partial class EmptyStatementSyntax : StatementSyntax
  {
    internal EmptyStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EmptyStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEmptyStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEmptyStatement(this);
    }

    public EmptyStatementSyntax Update(SyntaxToken eosToken)
    {
        if (eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.EmptyStatement(eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EmptyStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(eosToken);
    }
  }

  /// <summary>Represents a labeled statement syntax.</summary>
  public sealed partial class LabeledStatementSyntax : StatementSyntax
  {
    private StatementSyntax statement;

    internal LabeledStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LabeledStatementSyntax)this.Green).identifier, this.Position, 0); }
    }

    /// <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LabeledStatementSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.statement, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLabeledStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLabeledStatement(this);
    }

    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LabeledStatement(identifier, colonToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LabeledStatementSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.ColonToken, this.Statement);
    }

    public LabeledStatementSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Identifier, colonToken, this.Statement);
    }

    public LabeledStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.Identifier, this.ColonToken, statement);
    }
  }

  /// <summary>
  /// Represents a goto statement syntax
  /// </summary>
  public sealed partial class GotoStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal GotoStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the goto keyword.
    /// </summary>
    public SyntaxToken GotoKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.GotoStatementSyntax)this.Green).gotoKeyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the case or default keywords if any exists.
    /// </summary>
    public SyntaxToken CaseOrDefaultKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.GotoStatementSyntax)this.Green).caseOrDefaultKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    /// <summary>
    /// Gets a constant expression for a goto case statement.
    /// </summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
    /// </summary>
    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.GotoStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGotoStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGotoStatement(this);
    }

    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken eosToken)
    {
        if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.GotoStatement(this.Kind(), gotoKeyword, caseOrDefaultKeyword, expression, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public GotoStatementSyntax WithGotoKeyword(SyntaxToken gotoKeyword)
    {
        return this.Update(gotoKeyword, this.CaseOrDefaultKeyword, this.Expression, this.EosToken);
    }

    public GotoStatementSyntax WithCaseOrDefaultKeyword(SyntaxToken caseOrDefaultKeyword)
    {
        return this.Update(this.GotoKeyword, caseOrDefaultKeyword, this.Expression, this.EosToken);
    }

    public GotoStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.GotoKeyword, this.CaseOrDefaultKeyword, expression, this.EosToken);
    }

    public GotoStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.GotoKeyword, this.CaseOrDefaultKeyword, this.Expression, eosToken);
    }
  }

  public sealed partial class BreakStatementSyntax : StatementSyntax
  {
    internal BreakStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken BreakKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BreakStatementSyntax)this.Green).breakKeyword, this.Position, 0); }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BreakStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBreakStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBreakStatement(this);
    }

    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken eosToken)
    {
        if (breakKeyword != this.BreakKeyword || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.BreakStatement(breakKeyword, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BreakStatementSyntax WithBreakKeyword(SyntaxToken breakKeyword)
    {
        return this.Update(breakKeyword, this.EosToken);
    }

    public BreakStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.BreakKeyword, eosToken);
    }
  }

  public sealed partial class ContinueStatementSyntax : StatementSyntax
  {
    internal ContinueStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ContinueKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ContinueStatementSyntax)this.Green).continueKeyword, this.Position, 0); }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ContinueStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitContinueStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitContinueStatement(this);
    }

    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken eosToken)
    {
        if (continueKeyword != this.ContinueKeyword || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ContinueStatement(continueKeyword, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ContinueStatementSyntax WithContinueKeyword(SyntaxToken continueKeyword)
    {
        return this.Update(continueKeyword, this.EosToken);
    }

    public ContinueStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.ContinueKeyword, eosToken);
    }
  }

  public sealed partial class ReturnStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ReturnStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ReturnKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).returnKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ReturnStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReturnStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitReturnStatement(this);
    }

    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken eosToken)
    {
        if (returnKeyword != this.ReturnKeyword || expression != this.Expression || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ReturnStatement(returnKeyword, expression, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ReturnStatementSyntax WithReturnKeyword(SyntaxToken returnKeyword)
    {
        return this.Update(returnKeyword, this.Expression, this.EosToken);
    }

    public ReturnStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ReturnKeyword, expression, this.EosToken);
    }

    public ReturnStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.ReturnKeyword, this.Expression, eosToken);
    }
  }

  public sealed partial class ThrowStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal ThrowStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ThrowKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ThrowStatementSyntax)this.Green).throwKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ThrowStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThrowStatement(this);
    }

    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken eosToken)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ThrowStatement(throwKeyword, expression, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ThrowStatementSyntax WithThrowKeyword(SyntaxToken throwKeyword)
    {
        return this.Update(throwKeyword, this.Expression, this.EosToken);
    }

    public ThrowStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ThrowKeyword, expression, this.EosToken);
    }

    public ThrowStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.ThrowKeyword, this.Expression, eosToken);
    }
  }

  public sealed partial class YieldStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;

    internal YieldStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken YieldKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.YieldStatementSyntax)this.Green).yieldKeyword, this.Position, 0); }
    }

    public SyntaxToken ReturnOrBreakKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.YieldStatementSyntax)this.Green).returnOrBreakKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.YieldStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitYieldStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitYieldStatement(this);
    }

    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken eosToken)
    {
        if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.YieldStatement(this.Kind(), yieldKeyword, returnOrBreakKeyword, expression, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public YieldStatementSyntax WithYieldKeyword(SyntaxToken yieldKeyword)
    {
        return this.Update(yieldKeyword, this.ReturnOrBreakKeyword, this.Expression, this.EosToken);
    }

    public YieldStatementSyntax WithReturnOrBreakKeyword(SyntaxToken returnOrBreakKeyword)
    {
        return this.Update(this.YieldKeyword, returnOrBreakKeyword, this.Expression, this.EosToken);
    }

    public YieldStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.YieldKeyword, this.ReturnOrBreakKeyword, expression, this.EosToken);
    }

    public YieldStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.YieldKeyword, this.ReturnOrBreakKeyword, this.Expression, eosToken);
    }
  }

  public sealed partial class WhileStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax condition;
    private BlockSyntax statement;

    internal WhileStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhileKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.WhileStatementSyntax)this.Green).whileKeyword, this.Position, 0); }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 1);
        }
    }

    public BlockSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            case 2: return this.GetRed(ref this.statement, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            case 2: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhileStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhileStatement(this);
    }

    public WhileStatementSyntax Update(SyntaxToken whileKeyword, ExpressionSyntax condition, BlockSyntax statement)
    {
        if (whileKeyword != this.WhileKeyword || condition != this.Condition || statement != this.Statement)
        {
            var newNode = SyntaxFactory.WhileStatement(whileKeyword, condition, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public WhileStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)
    {
        return this.Update(whileKeyword, this.Condition, this.Statement);
    }

    public WhileStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.WhileKeyword, condition, this.Statement);
    }

    public WhileStatementSyntax WithStatement(BlockSyntax statement)
    {
        return this.Update(this.WhileKeyword, this.Condition, statement);
    }

    public WhileStatementSyntax AddStatementStatements(params StatementSyntax[] items)
    {
        return this.WithStatement(this.Statement.WithStatements(this.Statement.Statements.AddRange(items)));
    }
  }

  public sealed partial class DoStatementSyntax : StatementSyntax
  {
    private BlockSyntax statement;
    private ExpressionSyntax condition;

    internal DoStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken DoKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DoStatementSyntax)this.Green).doKeyword, this.Position, 0); }
    }

    public BlockSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 1);
        }
    }

    public SyntaxToken WhileKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DoStatementSyntax)this.Green).whileKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 3);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DoStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(4), this.GetChildIndex(4));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statement, 1);
            case 3: return this.GetRed(ref this.condition, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statement;
            case 3: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDoStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDoStatement(this);
    }

    public DoStatementSyntax Update(SyntaxToken doKeyword, BlockSyntax statement, SyntaxToken whileKeyword, ExpressionSyntax condition, SyntaxToken eosToken)
    {
        if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || condition != this.Condition || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.DoStatement(doKeyword, statement, whileKeyword, condition, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DoStatementSyntax WithDoKeyword(SyntaxToken doKeyword)
    {
        return this.Update(doKeyword, this.Statement, this.WhileKeyword, this.Condition, this.EosToken);
    }

    public DoStatementSyntax WithStatement(BlockSyntax statement)
    {
        return this.Update(this.DoKeyword, statement, this.WhileKeyword, this.Condition, this.EosToken);
    }

    public DoStatementSyntax WithWhileKeyword(SyntaxToken whileKeyword)
    {
        return this.Update(this.DoKeyword, this.Statement, whileKeyword, this.Condition, this.EosToken);
    }

    public DoStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, condition, this.EosToken);
    }

    public DoStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.DoKeyword, this.Statement, this.WhileKeyword, this.Condition, eosToken);
    }

    public DoStatementSyntax AddStatementStatements(params StatementSyntax[] items)
    {
        return this.WithStatement(this.Statement.WithStatements(this.Statement.Statements.AddRange(items)));
    }
  }

  public sealed partial class ForStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax variable;
    private ExpressionSyntax expression;
    private BlockSyntax statement;

    internal ForStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken AwaitKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ForStatementSyntax)this.Green).awaitKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    public SyntaxToken ForEachKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ForStatementSyntax)this.Green).forEachKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>
    /// The variable(s) of the loop. In correct code this is a tuple
    /// literal, declaration expression with a tuple designator, or
    /// a discard syntax in the form of a simple identifier. In broken
    /// code it could be something else.
    /// </summary>
    public ExpressionSyntax Variable 
    {
        get
        {
            return this.GetRed(ref this.variable, 2);
        }
    }

    public SyntaxToken InKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ForStatementSyntax)this.Green).inKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 4);
        }
    }

    public BlockSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 5);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.variable, 2);
            case 4: return this.GetRed(ref this.expression, 4);
            case 5: return this.GetRed(ref this.statement, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.variable;
            case 4: return this.expression;
            case 5: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitForStatement(this);
    }

    public ForStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, BlockSyntax statement)
    {
        if (awaitKeyword != this.AwaitKeyword || forEachKeyword != this.ForEachKeyword || variable != this.Variable || inKeyword != this.InKeyword || expression != this.Expression || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForStatement(awaitKeyword, forEachKeyword, variable, inKeyword, expression, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ForStatementSyntax WithAwaitKeyword(SyntaxToken awaitKeyword)
    {
        return this.Update(awaitKeyword, this.ForEachKeyword, this.Variable, this.InKeyword, this.Expression, this.Statement);
    }

    public ForStatementSyntax WithForEachKeyword(SyntaxToken forEachKeyword)
    {
        return this.Update(this.AwaitKeyword, forEachKeyword, this.Variable, this.InKeyword, this.Expression, this.Statement);
    }

    public ForStatementSyntax WithVariable(ExpressionSyntax variable)
    {
        return this.Update(this.AwaitKeyword, this.ForEachKeyword, variable, this.InKeyword, this.Expression, this.Statement);
    }

    public ForStatementSyntax WithInKeyword(SyntaxToken inKeyword)
    {
        return this.Update(this.AwaitKeyword, this.ForEachKeyword, this.Variable, inKeyword, this.Expression, this.Statement);
    }

    public ForStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.AwaitKeyword, this.ForEachKeyword, this.Variable, this.InKeyword, expression, this.Statement);
    }

    public ForStatementSyntax WithStatement(BlockSyntax statement)
    {
        return this.Update(this.AwaitKeyword, this.ForEachKeyword, this.Variable, this.InKeyword, this.Expression, statement);
    }

    public ForStatementSyntax AddStatementStatements(params StatementSyntax[] items)
    {
        return this.WithStatement(this.Statement.WithStatements(this.Statement.Statements.AddRange(items)));
    }
  }

  public sealed partial class UsingStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;
    private ExpressionSyntax expression;
    private StatementSyntax statement;

    internal UsingStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken AwaitKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UsingStatementSyntax)this.Green).awaitKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    public SyntaxToken UsingKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UsingStatementSyntax)this.Green).usingKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UsingStatementSyntax)this.Green).openParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 3);
        }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 4);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UsingStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 6);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 3: return this.GetRed(ref this.declaration, 3);
            case 4: return this.GetRed(ref this.expression, 4);
            case 6: return this.GetRed(ref this.statement, 6);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 3: return this.declaration;
            case 4: return this.expression;
            case 6: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUsingStatement(this);
    }

    public UsingStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (awaitKeyword != this.AwaitKeyword || usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.UsingStatement(awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UsingStatementSyntax WithAwaitKeyword(SyntaxToken awaitKeyword)
    {
        return this.Update(awaitKeyword, this.UsingKeyword, this.OpenParenToken, this.Declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithUsingKeyword(SyntaxToken usingKeyword)
    {
        return this.Update(this.AwaitKeyword, usingKeyword, this.OpenParenToken, this.Declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.AwaitKeyword, this.UsingKeyword, openParenToken, this.Declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.AwaitKeyword, this.UsingKeyword, this.OpenParenToken, declaration, this.Expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.AwaitKeyword, this.UsingKeyword, this.OpenParenToken, this.Declaration, expression, this.CloseParenToken, this.Statement);
    }

    public UsingStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.AwaitKeyword, this.UsingKeyword, this.OpenParenToken, this.Declaration, this.Expression, closeParenToken, this.Statement);
    }

    public UsingStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.AwaitKeyword, this.UsingKeyword, this.OpenParenToken, this.Declaration, this.Expression, this.CloseParenToken, statement);
    }
  }

  public sealed partial class InlineILStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax argument;

    internal InlineILStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the tokens identifying an IL instruction.</summary>
    public SyntaxTokenList Instruction 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    public ExpressionSyntax Argument 
    {
        get
        {
            return this.GetRed(ref this.argument, 1);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InlineILStatementSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.argument, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.argument;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInlineILStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInlineILStatement(this);
    }

    public InlineILStatementSyntax Update(SyntaxTokenList instruction, ExpressionSyntax argument, SyntaxToken eosToken)
    {
        if (instruction != this.Instruction || argument != this.Argument || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.InlineILStatement(instruction, argument, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public InlineILStatementSyntax WithInstruction(SyntaxTokenList instruction)
    {
        return this.Update(instruction, this.Argument, this.EosToken);
    }

    public InlineILStatementSyntax WithArgument(ExpressionSyntax argument)
    {
        return this.Update(this.Instruction, argument, this.EosToken);
    }

    public InlineILStatementSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.Instruction, this.Argument, eosToken);
    }

    public InlineILStatementSyntax AddInstruction(params SyntaxToken[] items)
    {
        return this.WithInstruction(this.Instruction.AddRange(items));
    }
  }

  public sealed partial class FixedStatementSyntax : StatementSyntax
  {
    private VariableDeclarationSyntax declaration;
    private StatementSyntax statement;

    internal FixedStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken FixedKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.FixedStatementSyntax)this.Green).fixedKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.FixedStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 2);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.FixedStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.declaration, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.declaration;
            case 4: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFixedStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFixedStatement(this);
    }

    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.FixedStatement(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FixedStatementSyntax WithFixedKeyword(SyntaxToken fixedKeyword)
    {
        return this.Update(fixedKeyword, this.OpenParenToken, this.Declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.FixedKeyword, openParenToken, this.Declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, declaration, this.CloseParenToken, this.Statement);
    }

    public FixedStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, this.Declaration, closeParenToken, this.Statement);
    }

    public FixedStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.FixedKeyword, this.OpenParenToken, this.Declaration, this.CloseParenToken, statement);
    }
  }

  public sealed partial class CheckedStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;

    internal CheckedStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CheckedStatementSyntax)this.Green).keyword, this.Position, 0); }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCheckedStatement(this);
    }

    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)
    {
        if (keyword != this.Keyword || block != this.Block)
        {
            var newNode = SyntaxFactory.CheckedStatement(this.Kind(), keyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CheckedStatementSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.Block);
    }

    public CheckedStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.Keyword, block);
    }

    public CheckedStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }
  }

  public sealed partial class UnsafeStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;

    internal UnsafeStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken UnsafeKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UnsafeStatementSyntax)this.Green).unsafeKeyword, this.Position, 0); }
    }

    public SyntaxToken IlKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UnsafeStatementSyntax)this.Green).ilKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.block, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUnsafeStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUnsafeStatement(this);
    }

    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, SyntaxToken ilKeyword, BlockSyntax block)
    {
        if (unsafeKeyword != this.UnsafeKeyword || ilKeyword != this.IlKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.UnsafeStatement(unsafeKeyword, ilKeyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public UnsafeStatementSyntax WithUnsafeKeyword(SyntaxToken unsafeKeyword)
    {
        return this.Update(unsafeKeyword, this.IlKeyword, this.Block);
    }

    public UnsafeStatementSyntax WithIlKeyword(SyntaxToken ilKeyword)
    {
        return this.Update(this.UnsafeKeyword, ilKeyword, this.Block);
    }

    public UnsafeStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.UnsafeKeyword, this.IlKeyword, block);
    }

    public UnsafeStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }
  }

  public sealed partial class LockStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;
    private StatementSyntax statement;

    internal LockStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LockKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LockStatementSyntax)this.Green).lockKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LockStatementSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LockStatementSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 4: return this.GetRed(ref this.statement, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 4: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLockStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLockStatement(this);
    }

    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LockStatement(lockKeyword, openParenToken, expression, closeParenToken, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public LockStatementSyntax WithLockKeyword(SyntaxToken lockKeyword)
    {
        return this.Update(lockKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.LockKeyword, openParenToken, this.Expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, expression, this.CloseParenToken, this.Statement);
    }

    public LockStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, this.Expression, closeParenToken, this.Statement);
    }

    public LockStatementSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.LockKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, statement);
    }
  }

  /// <summary>
  /// Represents an if statement syntax.
  /// </summary>
  public sealed partial class IfStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax condition;
    private BlockSyntax statement;
    private ElseClauseSyntax @else;

    internal IfStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the if keyword.
    /// </summary>
    public SyntaxToken IfKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfStatementSyntax)this.Green).ifKeyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets an ExpressionSyntax that represents the condition of the if statement.
    /// </summary>
    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 1);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the then keyword.
    /// </summary>
    public SyntaxToken ThenKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfStatementSyntax)this.Green).thenKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>
    /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
    /// </summary>
    public BlockSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 3);
        }
    }

    /// <summary>
    /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
    /// </summary>
    public ElseClauseSyntax Else 
    {
        get
        {
            return this.GetRed(ref this.@else, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            case 3: return this.GetRed(ref this.statement, 3);
            case 4: return this.GetRed(ref this.@else, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            case 3: return this.statement;
            case 4: return this.@else;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfStatement(this);
    }

    public IfStatementSyntax Update(SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken thenKeyword, BlockSyntax statement, ElseClauseSyntax @else)
    {
        if (ifKeyword != this.IfKeyword || condition != this.Condition || thenKeyword != this.ThenKeyword || statement != this.Statement || @else != this.Else)
        {
            var newNode = SyntaxFactory.IfStatement(ifKeyword, condition, thenKeyword, statement, @else);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IfStatementSyntax WithIfKeyword(SyntaxToken ifKeyword)
    {
        return this.Update(ifKeyword, this.Condition, this.ThenKeyword, this.Statement, this.Else);
    }

    public IfStatementSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.IfKeyword, condition, this.ThenKeyword, this.Statement, this.Else);
    }

    public IfStatementSyntax WithThenKeyword(SyntaxToken thenKeyword)
    {
        return this.Update(this.IfKeyword, this.Condition, thenKeyword, this.Statement, this.Else);
    }

    public IfStatementSyntax WithStatement(BlockSyntax statement)
    {
        return this.Update(this.IfKeyword, this.Condition, this.ThenKeyword, statement, this.Else);
    }

    public IfStatementSyntax WithElse(ElseClauseSyntax @else)
    {
        return this.Update(this.IfKeyword, this.Condition, this.ThenKeyword, this.Statement, @else);
    }

    public IfStatementSyntax AddStatementStatements(params StatementSyntax[] items)
    {
        return this.WithStatement(this.Statement.WithStatements(this.Statement.Statements.AddRange(items)));
    }
  }

  /// <summary>Represents an else statement syntax.</summary>
  public sealed partial class ElseClauseSyntax : CSharpSyntaxNode
  {
    private StatementSyntax statement;

    internal ElseClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a syntax token
    /// </summary>
    public SyntaxToken ElseKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElseClauseSyntax)this.Green).elseKeyword, this.Position, 0); }
    }

    public StatementSyntax Statement 
    {
        get
        {
            return this.GetRed(ref this.statement, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.statement, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.statement;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElseClause(this);
    }

    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
    {
        if (elseKeyword != this.ElseKeyword || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ElseClauseSyntax WithElseKeyword(SyntaxToken elseKeyword)
    {
        return this.Update(elseKeyword, this.Statement);
    }

    public ElseClauseSyntax WithStatement(StatementSyntax statement)
    {
        return this.Update(this.ElseKeyword, statement);
    }
  }

  /// <summary>Represents a switch statement syntax.</summary>
  public sealed partial class SwitchStatementSyntax : StatementSyntax
  {
    private ExpressionSyntax expression;
    private SyntaxNode sections;

    internal SwitchStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the switch keyword.
    /// </summary>
    public SyntaxToken SwitchKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).switchKeyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
    /// </summary>
    public SyntaxToken OpenParenToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).openParenToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    /// <summary>
    /// Gets an ExpressionSyntax representing the expression of the switch statement.
    /// </summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.
    /// </summary>
    public SyntaxToken CloseParenToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).closeParenToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
    /// </summary>
    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).openBraceToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
    /// </summary>
    public SyntaxList<SwitchSectionSyntax> Sections 
    {
        get
        {
            return new SyntaxList<SwitchSectionSyntax>(this.GetRed(ref this.sections, 5));
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the open braces following the switch sections.
    /// </summary>
    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchStatementSyntax)this.Green).closeBraceToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.expression, 2);
            case 5: return this.GetRed(ref this.sections, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.expression;
            case 5: return this.sections;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchStatement(this);
    }

    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
        if (switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.SwitchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchStatementSyntax WithSwitchKeyword(SyntaxToken switchKeyword)
    {
        return this.Update(switchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.SwitchKeyword, openParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, closeParenToken, this.OpenBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, openBraceToken, this.Sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithSections(SyntaxList<SwitchSectionSyntax> sections)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, sections, this.CloseBraceToken);
    }

    public SwitchStatementSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.SwitchKeyword, this.OpenParenToken, this.Expression, this.CloseParenToken, this.OpenBraceToken, this.Sections, closeBraceToken);
    }

    public SwitchStatementSyntax AddSections(params SwitchSectionSyntax[] items)
    {
        return this.WithSections(this.Sections.AddRange(items));
    }
  }

  /// <summary>Represents a switch section syntax of a switch statement.</summary>
  public sealed partial class SwitchSectionSyntax : CSharpSyntaxNode
  {
    private SyntaxNode labels;
    private SyntaxNode statements;

    internal SwitchSectionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
    /// </summary>
    public SyntaxList<SwitchLabelSyntax> Labels 
    {
        get
        {
            return new SyntaxList<SwitchLabelSyntax>(this.GetRed(ref this.labels, 0));
        }
    }

    /// <summary>
    /// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
    /// </summary>
    public SyntaxList<StatementSyntax> Statements 
    {
        get
        {
            return new SyntaxList<StatementSyntax>(this.GetRed(ref this.statements, 1));
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.labels);
            case 1: return this.GetRed(ref this.statements, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.labels;
            case 1: return this.statements;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchSection(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchSection(this);
    }

    public SwitchSectionSyntax Update(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
        if (labels != this.Labels || statements != this.Statements)
        {
            var newNode = SyntaxFactory.SwitchSection(labels, statements);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchSectionSyntax WithLabels(SyntaxList<SwitchLabelSyntax> labels)
    {
        return this.Update(labels, this.Statements);
    }

    public SwitchSectionSyntax WithStatements(SyntaxList<StatementSyntax> statements)
    {
        return this.Update(this.Labels, statements);
    }

    public SwitchSectionSyntax AddLabels(params SwitchLabelSyntax[] items)
    {
        return this.WithLabels(this.Labels.AddRange(items));
    }

    public SwitchSectionSyntax AddStatements(params StatementSyntax[] items)
    {
        return this.WithStatements(this.Statements.AddRange(items));
    }
  }

  /// <summary>Represents a switch label within a switch statement.</summary>
  public abstract partial class SwitchLabelSyntax : CSharpSyntaxNode
  {
    internal SwitchLabelSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents a case or default keyword that belongs to a switch label.
    /// </summary>
    public abstract SyntaxToken Keyword { get; }
    public SwitchLabelSyntax WithKeyword(SyntaxToken keyword) => WithKeywordCore(keyword);
    internal abstract SwitchLabelSyntax WithKeywordCore(SyntaxToken keyword);

    /// <summary>
    /// Gets a SyntaxToken that represents the colon that terminates the switch label.
    /// </summary>
    public abstract SyntaxToken ColonToken { get; }
    public SwitchLabelSyntax WithColonToken(SyntaxToken colonToken) => WithColonTokenCore(colonToken);
    internal abstract SwitchLabelSyntax WithColonTokenCore(SyntaxToken colonToken);
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  public sealed partial class CasePatternSwitchLabelSyntax : SwitchLabelSyntax
  {
    private PatternSyntax pattern;
    private WhenClauseSyntax whenClause;

    internal CasePatternSwitchLabelSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CasePatternSwitchLabelSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets a PatternSyntax that represents the pattern that gets matched for the case label.
    /// </summary>
    public PatternSyntax Pattern 
    {
        get
        {
            return this.GetRed(ref this.pattern, 1);
        }
    }

    public WhenClauseSyntax WhenClause 
    {
        get
        {
            return this.GetRed(ref this.whenClause, 2);
        }
    }

    public override SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CasePatternSwitchLabelSyntax)this.Green).colonToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.pattern, 1);
            case 2: return this.GetRed(ref this.whenClause, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.pattern;
            case 2: return this.whenClause;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCasePatternSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCasePatternSwitchLabel(this);
    }

    public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || pattern != this.Pattern || whenClause != this.WhenClause || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CasePatternSwitchLabel(keyword, pattern, whenClause, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SwitchLabelSyntax WithKeywordCore(SyntaxToken keyword) => WithKeyword(keyword);
    public new CasePatternSwitchLabelSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.Pattern, this.WhenClause, this.ColonToken);
    }

    public CasePatternSwitchLabelSyntax WithPattern(PatternSyntax pattern)
    {
        return this.Update(this.Keyword, pattern, this.WhenClause, this.ColonToken);
    }

    public CasePatternSwitchLabelSyntax WithWhenClause(WhenClauseSyntax whenClause)
    {
        return this.Update(this.Keyword, this.Pattern, whenClause, this.ColonToken);
    }

    internal override SwitchLabelSyntax WithColonTokenCore(SyntaxToken colonToken) => WithColonToken(colonToken);
    public new CasePatternSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Keyword, this.Pattern, this.WhenClause, colonToken);
    }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  public sealed partial class CaseSwitchLabelSyntax : SwitchLabelSyntax
  {
    private ExpressionSyntax value;

    internal CaseSwitchLabelSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CaseSwitchLabelSyntax)this.Green).keyword, this.Position, 0); }
    }

    /// <summary>
    /// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
    /// </summary>
    public ExpressionSyntax Value 
    {
        get
        {
            return this.GetRed(ref this.value, 1);
        }
    }

    public override SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CaseSwitchLabelSyntax)this.Green).colonToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.value, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.value;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCaseSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCaseSwitchLabel(this);
    }

    public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || value != this.Value || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CaseSwitchLabel(keyword, value, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SwitchLabelSyntax WithKeywordCore(SyntaxToken keyword) => WithKeyword(keyword);
    public new CaseSwitchLabelSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.Value, this.ColonToken);
    }

    public CaseSwitchLabelSyntax WithValue(ExpressionSyntax value)
    {
        return this.Update(this.Keyword, value, this.ColonToken);
    }

    internal override SwitchLabelSyntax WithColonTokenCore(SyntaxToken colonToken) => WithColonToken(colonToken);
    public new CaseSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Keyword, this.Value, colonToken);
    }
  }

  /// <summary>Represents a default label within a switch statement.</summary>
  public sealed partial class DefaultSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal DefaultSwitchLabelSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the default keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefaultSwitchLabelSyntax)this.Green).keyword, this.Position, 0); }
    }

    public override SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefaultSwitchLabelSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefaultSwitchLabel(this);
    }

    public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.DefaultSwitchLabel(keyword, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override SwitchLabelSyntax WithKeywordCore(SyntaxToken keyword) => WithKeyword(keyword);
    public new DefaultSwitchLabelSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(keyword, this.ColonToken);
    }

    internal override SwitchLabelSyntax WithColonTokenCore(SyntaxToken colonToken) => WithColonToken(colonToken);
    public new DefaultSwitchLabelSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Keyword, colonToken);
    }
  }

  public sealed partial class SwitchExpressionSyntax : ExpressionSyntax
  {
    private ExpressionSyntax governingExpression;
    private SyntaxNode arms;

    internal SwitchExpressionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public ExpressionSyntax GoverningExpression 
    {
        get
        {
            return this.GetRedAtZero(ref this.governingExpression);
        }
    }

    public SyntaxToken SwitchKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchExpressionSyntax)this.Green).switchKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchExpressionSyntax)this.Green).openBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SeparatedSyntaxList<SwitchExpressionArmSyntax> Arms 
    {
        get
        {
            var red = this.GetRed(ref this.arms, 3);
            if (red != null)
                return new SeparatedSyntaxList<SwitchExpressionArmSyntax>(red, this.GetChildIndex(3));

            return default(SeparatedSyntaxList<SwitchExpressionArmSyntax>);
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchExpressionSyntax)this.Green).closeBraceToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.governingExpression);
            case 3: return this.GetRed(ref this.arms, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.governingExpression;
            case 3: return this.arms;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchExpression(this);
    }

    public SwitchExpressionSyntax Update(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
    {
        if (governingExpression != this.GoverningExpression || switchKeyword != this.SwitchKeyword || openBraceToken != this.OpenBraceToken || arms != this.Arms || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.SwitchExpression(governingExpression, switchKeyword, openBraceToken, arms, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchExpressionSyntax WithGoverningExpression(ExpressionSyntax governingExpression)
    {
        return this.Update(governingExpression, this.SwitchKeyword, this.OpenBraceToken, this.Arms, this.CloseBraceToken);
    }

    public SwitchExpressionSyntax WithSwitchKeyword(SyntaxToken switchKeyword)
    {
        return this.Update(this.GoverningExpression, switchKeyword, this.OpenBraceToken, this.Arms, this.CloseBraceToken);
    }

    public SwitchExpressionSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.GoverningExpression, this.SwitchKeyword, openBraceToken, this.Arms, this.CloseBraceToken);
    }

    public SwitchExpressionSyntax WithArms(SeparatedSyntaxList<SwitchExpressionArmSyntax> arms)
    {
        return this.Update(this.GoverningExpression, this.SwitchKeyword, this.OpenBraceToken, arms, this.CloseBraceToken);
    }

    public SwitchExpressionSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.GoverningExpression, this.SwitchKeyword, this.OpenBraceToken, this.Arms, closeBraceToken);
    }

    public SwitchExpressionSyntax AddArms(params SwitchExpressionArmSyntax[] items)
    {
        return this.WithArms(this.Arms.AddRange(items));
    }
  }

  public sealed partial class SwitchExpressionArmSyntax : CSharpSyntaxNode
  {
    private PatternSyntax pattern;
    private WhenClauseSyntax whenClause;
    private ExpressionSyntax expression;

    internal SwitchExpressionArmSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public PatternSyntax Pattern 
    {
        get
        {
            return this.GetRedAtZero(ref this.pattern);
        }
    }

    public WhenClauseSyntax WhenClause 
    {
        get
        {
            return this.GetRed(ref this.whenClause, 1);
        }
    }

    public SyntaxToken EqualsGreaterThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.SwitchExpressionArmSyntax)this.Green).equalsGreaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.pattern);
            case 1: return this.GetRed(ref this.whenClause, 1);
            case 3: return this.GetRed(ref this.expression, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.pattern;
            case 1: return this.whenClause;
            case 3: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchExpressionArm(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchExpressionArm(this);
    }

    public SwitchExpressionArmSyntax Update(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
    {
        if (pattern != this.Pattern || whenClause != this.WhenClause || equalsGreaterThanToken != this.EqualsGreaterThanToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.SwitchExpressionArm(pattern, whenClause, equalsGreaterThanToken, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SwitchExpressionArmSyntax WithPattern(PatternSyntax pattern)
    {
        return this.Update(pattern, this.WhenClause, this.EqualsGreaterThanToken, this.Expression);
    }

    public SwitchExpressionArmSyntax WithWhenClause(WhenClauseSyntax whenClause)
    {
        return this.Update(this.Pattern, whenClause, this.EqualsGreaterThanToken, this.Expression);
    }

    public SwitchExpressionArmSyntax WithEqualsGreaterThanToken(SyntaxToken equalsGreaterThanToken)
    {
        return this.Update(this.Pattern, this.WhenClause, equalsGreaterThanToken, this.Expression);
    }

    public SwitchExpressionArmSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.Pattern, this.WhenClause, this.EqualsGreaterThanToken, expression);
    }
  }

  public sealed partial class TryStatementSyntax : StatementSyntax
  {
    private BlockSyntax block;
    private SyntaxNode catches;
    private FinallyClauseSyntax @finally;

    internal TryStatementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken TryKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TryStatementSyntax)this.Green).tryKeyword, this.Position, 0); }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 1);
        }
    }

    public SyntaxList<CatchClauseSyntax> Catches 
    {
        get
        {
            return new SyntaxList<CatchClauseSyntax>(this.GetRed(ref this.catches, 2));
        }
    }

    public FinallyClauseSyntax Finally 
    {
        get
        {
            return this.GetRed(ref this.@finally, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            case 2: return this.GetRed(ref this.catches, 2);
            case 3: return this.GetRed(ref this.@finally, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            case 2: return this.catches;
            case 3: return this.@finally;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTryStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTryStatement(this);
    }

    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
        if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
        {
            var newNode = SyntaxFactory.TryStatement(tryKeyword, block, catches, @finally);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TryStatementSyntax WithTryKeyword(SyntaxToken tryKeyword)
    {
        return this.Update(tryKeyword, this.Block, this.Catches, this.Finally);
    }

    public TryStatementSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.TryKeyword, block, this.Catches, this.Finally);
    }

    public TryStatementSyntax WithCatches(SyntaxList<CatchClauseSyntax> catches)
    {
        return this.Update(this.TryKeyword, this.Block, catches, this.Finally);
    }

    public TryStatementSyntax WithFinally(FinallyClauseSyntax @finally)
    {
        return this.Update(this.TryKeyword, this.Block, this.Catches, @finally);
    }

    public TryStatementSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }

    public TryStatementSyntax AddCatches(params CatchClauseSyntax[] items)
    {
        return this.WithCatches(this.Catches.AddRange(items));
    }
  }

  public sealed partial class CatchClauseSyntax : CSharpSyntaxNode
  {
    private CatchDeclarationSyntax declaration;
    private CatchFilterClauseSyntax filter;
    private BlockSyntax block;

    internal CatchClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken CatchKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CatchClauseSyntax)this.Green).catchKeyword, this.Position, 0); }
    }

    public CatchDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 1);
        }
    }

    public CatchFilterClauseSyntax Filter 
    {
        get
        {
            return this.GetRed(ref this.filter, 2);
        }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.declaration, 1);
            case 2: return this.GetRed(ref this.filter, 2);
            case 3: return this.GetRed(ref this.block, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.declaration;
            case 2: return this.filter;
            case 3: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchClause(this);
    }

    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
        if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || filter != this.Filter || block != this.Block)
        {
            var newNode = SyntaxFactory.CatchClause(catchKeyword, declaration, filter, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CatchClauseSyntax WithCatchKeyword(SyntaxToken catchKeyword)
    {
        return this.Update(catchKeyword, this.Declaration, this.Filter, this.Block);
    }

    public CatchClauseSyntax WithDeclaration(CatchDeclarationSyntax declaration)
    {
        return this.Update(this.CatchKeyword, declaration, this.Filter, this.Block);
    }

    public CatchClauseSyntax WithFilter(CatchFilterClauseSyntax filter)
    {
        return this.Update(this.CatchKeyword, this.Declaration, filter, this.Block);
    }

    public CatchClauseSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.CatchKeyword, this.Declaration, this.Filter, block);
    }

    public CatchClauseSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }
  }

  public sealed partial class CatchDeclarationSyntax : CSharpSyntaxNode
  {
    private TypeSyntax type;

    internal CatchDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CatchDeclarationSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    public SyntaxToken Identifier 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CatchDeclarationSyntax)this.Green).identifier;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CatchDeclarationSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchDeclaration(this);
    }

    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CatchDeclarationSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Type, this.Identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.OpenParenToken, type, this.Identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.OpenParenToken, this.Type, identifier, this.CloseParenToken);
    }

    public CatchDeclarationSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Type, this.Identifier, closeParenToken);
    }
  }

  public sealed partial class CatchFilterClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax filterExpression;

    internal CatchFilterClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhenKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CatchFilterClauseSyntax)this.Green).whenKeyword, this.Position, 0); }
    }

    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CatchFilterClauseSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ExpressionSyntax FilterExpression 
    {
        get
        {
            return this.GetRed(ref this.filterExpression, 2);
        }
    }

    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CatchFilterClauseSyntax)this.Green).closeParenToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.filterExpression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.filterExpression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchFilterClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchFilterClause(this);
    }

    public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
        if (whenKeyword != this.WhenKeyword || openParenToken != this.OpenParenToken || filterExpression != this.FilterExpression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchFilterClause(whenKeyword, openParenToken, filterExpression, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CatchFilterClauseSyntax WithWhenKeyword(SyntaxToken whenKeyword)
    {
        return this.Update(whenKeyword, this.OpenParenToken, this.FilterExpression, this.CloseParenToken);
    }

    public CatchFilterClauseSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.WhenKeyword, openParenToken, this.FilterExpression, this.CloseParenToken);
    }

    public CatchFilterClauseSyntax WithFilterExpression(ExpressionSyntax filterExpression)
    {
        return this.Update(this.WhenKeyword, this.OpenParenToken, filterExpression, this.CloseParenToken);
    }

    public CatchFilterClauseSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.WhenKeyword, this.OpenParenToken, this.FilterExpression, closeParenToken);
    }
  }

  public sealed partial class FinallyClauseSyntax : CSharpSyntaxNode
  {
    private BlockSyntax block;

    internal FinallyClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken FinallyKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.FinallyClauseSyntax)this.Green).finallyKeyword, this.Position, 0); }
    }

    public BlockSyntax Block 
    {
        get
        {
            return this.GetRed(ref this.block, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.block, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.block;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFinallyClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFinallyClause(this);
    }

    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)
    {
        if (finallyKeyword != this.FinallyKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.FinallyClause(finallyKeyword, block);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public FinallyClauseSyntax WithFinallyKeyword(SyntaxToken finallyKeyword)
    {
        return this.Update(finallyKeyword, this.Block);
    }

    public FinallyClauseSyntax WithBlock(BlockSyntax block)
    {
        return this.Update(this.FinallyKeyword, block);
    }

    public FinallyClauseSyntax AddBlockStatements(params StatementSyntax[] items)
    {
        return this.WithBlock(this.Block.WithStatements(this.Block.Statements.AddRange(items)));
    }
  }

  public sealed partial class CompilationUnitSyntax : CSharpSyntaxNode
  {
    private SyntaxNode externs;
    private SyntaxNode usings;
    private SyntaxNode attributeLists;
    private SyntaxNode members;

    internal CompilationUnitSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxList<ExternAliasDirectiveSyntax> Externs 
    {
        get
        {
            return new SyntaxList<ExternAliasDirectiveSyntax>(this.GetRed(ref this.externs, 0));
        }
    }

    public SyntaxList<ImportDirectiveSyntax> Usings 
    {
        get
        {
            return new SyntaxList<ImportDirectiveSyntax>(this.GetRed(ref this.usings, 1));
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 2));
        }
    }

    public SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 3));
        }
    }

    public SyntaxToken EndOfFileToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CompilationUnitSyntax)this.Green).endOfFileToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.externs);
            case 1: return this.GetRed(ref this.usings, 1);
            case 2: return this.GetRed(ref this.attributeLists, 2);
            case 3: return this.GetRed(ref this.members, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externs;
            case 1: return this.usings;
            case 2: return this.attributeLists;
            case 3: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCompilationUnit(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCompilationUnit(this);
    }

    public CompilationUnitSyntax Update(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<ImportDirectiveSyntax> usings, SyntaxList<AttributeSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
        if (externs != this.Externs || usings != this.Usings || attributeLists != this.AttributeLists || members != this.Members || endOfFileToken != this.EndOfFileToken)
        {
            var newNode = SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, endOfFileToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CompilationUnitSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs)
    {
        return this.Update(externs, this.Usings, this.AttributeLists, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithUsings(SyntaxList<ImportDirectiveSyntax> usings)
    {
        return this.Update(this.Externs, usings, this.AttributeLists, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(this.Externs, this.Usings, attributeLists, this.Members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.Externs, this.Usings, this.AttributeLists, members, this.EndOfFileToken);
    }

    public CompilationUnitSyntax WithEndOfFileToken(SyntaxToken endOfFileToken)
    {
        return this.Update(this.Externs, this.Usings, this.AttributeLists, this.Members, endOfFileToken);
    }

    public CompilationUnitSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)
    {
        return this.WithExterns(this.Externs.AddRange(items));
    }

    public CompilationUnitSyntax AddUsings(params ImportDirectiveSyntax[] items)
    {
        return this.WithUsings(this.Usings.AddRange(items));
    }

    public CompilationUnitSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public CompilationUnitSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>
  /// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
  /// </summary>
  public sealed partial class ExternAliasDirectiveSyntax : CSharpSyntaxNode
  {
    internal ExternAliasDirectiveSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>SyntaxToken representing the extern keyword.</summary>
    public SyntaxToken ExternKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ExternAliasDirectiveSyntax)this.Green).externKeyword, this.Position, 0); }
    }

    /// <summary>SyntaxToken representing the alias keyword.</summary>
    public SyntaxToken AliasKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ExternAliasDirectiveSyntax)this.Green).aliasKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ExternAliasDirectiveSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>SyntaxToken representing the semicolon token.</summary>
    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ExternAliasDirectiveSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExternAliasDirective(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExternAliasDirective(this);
    }

    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken eosToken)
    {
        if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ExternAliasDirective(externKeyword, aliasKeyword, identifier, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExternAliasDirectiveSyntax WithExternKeyword(SyntaxToken externKeyword)
    {
        return this.Update(externKeyword, this.AliasKeyword, this.Identifier, this.EosToken);
    }

    public ExternAliasDirectiveSyntax WithAliasKeyword(SyntaxToken aliasKeyword)
    {
        return this.Update(this.ExternKeyword, aliasKeyword, this.Identifier, this.EosToken);
    }

    public ExternAliasDirectiveSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.ExternKeyword, this.AliasKeyword, identifier, this.EosToken);
    }

    public ExternAliasDirectiveSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.ExternKeyword, this.AliasKeyword, this.Identifier, eosToken);
    }
  }

  public sealed partial class ImportDirectiveSyntax : CSharpSyntaxNode
  {
    private NameEqualsSyntax alias;
    private NameSyntax name;

    internal ImportDirectiveSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ImportKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImportDirectiveSyntax)this.Green).importKeyword, this.Position, 0); }
    }

    public SyntaxToken StaticKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImportDirectiveSyntax)this.Green).staticKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    public NameEqualsSyntax Alias 
    {
        get
        {
            return this.GetRed(ref this.alias, 2);
        }
    }

    public NameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 3);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImportDirectiveSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(4), this.GetChildIndex(4));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.alias, 2);
            case 3: return this.GetRed(ref this.name, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.alias;
            case 3: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImportDirective(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImportDirective(this);
    }

    public ImportDirectiveSyntax Update(SyntaxToken importKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken eosToken)
    {
        if (importKeyword != this.ImportKeyword || staticKeyword != this.StaticKeyword || alias != this.Alias || name != this.Name || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ImportDirective(importKeyword, staticKeyword, alias, name, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ImportDirectiveSyntax WithImportKeyword(SyntaxToken importKeyword)
    {
        return this.Update(importKeyword, this.StaticKeyword, this.Alias, this.Name, this.EosToken);
    }

    public ImportDirectiveSyntax WithStaticKeyword(SyntaxToken staticKeyword)
    {
        return this.Update(this.ImportKeyword, staticKeyword, this.Alias, this.Name, this.EosToken);
    }

    public ImportDirectiveSyntax WithAlias(NameEqualsSyntax alias)
    {
        return this.Update(this.ImportKeyword, this.StaticKeyword, alias, this.Name, this.EosToken);
    }

    public ImportDirectiveSyntax WithName(NameSyntax name)
    {
        return this.Update(this.ImportKeyword, this.StaticKeyword, this.Alias, name, this.EosToken);
    }

    public ImportDirectiveSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.ImportKeyword, this.StaticKeyword, this.Alias, this.Name, eosToken);
    }
  }

  /// <summary>Member declaration syntax.</summary>
  public abstract partial class MemberDeclarationSyntax : CSharpSyntaxNode
  {
    internal MemberDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
  {
    private NameSyntax name;
    private SyntaxNode externs;
    private SyntaxNode usings;
    private SyntaxNode members;

    internal NamespaceDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken NamespaceKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NamespaceDeclarationSyntax)this.Green).namespaceKeyword, this.Position, 0); }
    }

    public NameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NamespaceDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxList<ExternAliasDirectiveSyntax> Externs 
    {
        get
        {
            return new SyntaxList<ExternAliasDirectiveSyntax>(this.GetRed(ref this.externs, 3));
        }
    }

    public SyntaxList<ImportDirectiveSyntax> Usings 
    {
        get
        {
            return new SyntaxList<ImportDirectiveSyntax>(this.GetRed(ref this.usings, 4));
        }
    }

    public SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 5));
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NamespaceDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 3: return this.GetRed(ref this.externs, 3);
            case 4: return this.GetRed(ref this.usings, 4);
            case 5: return this.GetRed(ref this.members, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 3: return this.externs;
            case 4: return this.usings;
            case 5: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNamespaceDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNamespaceDeclaration(this);
    }

    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<ImportDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken)
    {
        if (namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.NamespaceDeclaration(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NamespaceDeclarationSyntax WithNamespaceKeyword(SyntaxToken namespaceKeyword)
    {
        return this.Update(namespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken);
    }

    public NamespaceDeclarationSyntax WithName(NameSyntax name)
    {
        return this.Update(this.NamespaceKeyword, name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken);
    }

    public NamespaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.NamespaceKeyword, this.Name, openBraceToken, this.Externs, this.Usings, this.Members, this.CloseBraceToken);
    }

    public NamespaceDeclarationSyntax WithExterns(SyntaxList<ExternAliasDirectiveSyntax> externs)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, externs, this.Usings, this.Members, this.CloseBraceToken);
    }

    public NamespaceDeclarationSyntax WithUsings(SyntaxList<ImportDirectiveSyntax> usings)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, usings, this.Members, this.CloseBraceToken);
    }

    public NamespaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, members, this.CloseBraceToken);
    }

    public NamespaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.NamespaceKeyword, this.Name, this.OpenBraceToken, this.Externs, this.Usings, this.Members, closeBraceToken);
    }

    public NamespaceDeclarationSyntax AddExterns(params ExternAliasDirectiveSyntax[] items)
    {
        return this.WithExterns(this.Externs.AddRange(items));
    }

    public NamespaceDeclarationSyntax AddUsings(params ImportDirectiveSyntax[] items)
    {
        return this.WithUsings(this.Usings.AddRange(items));
    }

    public NamespaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Class representing what language construct an attribute targets.</summary>
  public sealed partial class AttributeTargetSpecifierSyntax : CSharpSyntaxNode
  {
    internal AttributeTargetSpecifierSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax)this.Green).identifier, this.Position, 0); }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeTargetSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeTargetSpecifier(this);
    }

    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.AttributeTargetSpecifier(identifier, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeTargetSpecifierSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(identifier, this.ColonToken);
    }

    public AttributeTargetSpecifierSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Identifier, colonToken);
    }
  }

  /// <summary>Attribute syntax.</summary>
  public sealed partial class AttributeSyntax : CSharpSyntaxNode
  {
    private AttributeTargetSpecifierSyntax target;
    private NameSyntax name;
    private AttributeArgumentListSyntax argumentList;

    internal AttributeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the at token.</summary>
    public SyntaxToken AtToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AttributeSyntax)this.Green).atToken, this.Position, 0); }
    }

    /// <summary>Gets the optional construct targeted by the attribute.</summary>
    public AttributeTargetSpecifierSyntax Target 
    {
        get
        {
            return this.GetRed(ref this.target, 1);
        }
    }

    /// <summary>Gets the name.</summary>
    public NameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 2);
        }
    }

    public AttributeArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.target, 1);
            case 2: return this.GetRed(ref this.name, 2);
            case 3: return this.GetRed(ref this.argumentList, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.target;
            case 2: return this.name;
            case 3: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttribute(this);
    }

    public AttributeSyntax Update(SyntaxToken atToken, AttributeTargetSpecifierSyntax target, NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
        if (atToken != this.AtToken || target != this.Target || name != this.Name || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.Attribute(atToken, target, name, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeSyntax WithAtToken(SyntaxToken atToken)
    {
        return this.Update(atToken, this.Target, this.Name, this.ArgumentList);
    }

    public AttributeSyntax WithTarget(AttributeTargetSpecifierSyntax target)
    {
        return this.Update(this.AtToken, target, this.Name, this.ArgumentList);
    }

    public AttributeSyntax WithName(NameSyntax name)
    {
        return this.Update(this.AtToken, this.Target, name, this.ArgumentList);
    }

    public AttributeSyntax WithArgumentList(AttributeArgumentListSyntax argumentList)
    {
        return this.Update(this.AtToken, this.Target, this.Name, argumentList);
    }

    public AttributeSyntax AddArgumentListArguments(params AttributeArgumentSyntax[] items)
    {
        var argumentList = this.ArgumentList ?? SyntaxFactory.AttributeArgumentList();
        return this.WithArgumentList(argumentList.WithArguments(argumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Attribute argument list syntax.</summary>
  public sealed partial class AttributeArgumentListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode arguments;

    internal AttributeArgumentListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AttributeArgumentListSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    /// <summary>Gets the arguments syntax list.</summary>
    public SeparatedSyntaxList<AttributeArgumentSyntax> Arguments 
    {
        get
        {
            var red = this.GetRed(ref this.arguments, 1);
            if (red != null)
                return new SeparatedSyntaxList<AttributeArgumentSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<AttributeArgumentSyntax>);
        }
    }

    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AttributeArgumentListSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.arguments, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.arguments;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgumentList(this);
    }

    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeArgumentListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Arguments, this.CloseParenToken);
    }

    public AttributeArgumentListSyntax WithArguments(SeparatedSyntaxList<AttributeArgumentSyntax> arguments)
    {
        return this.Update(this.OpenParenToken, arguments, this.CloseParenToken);
    }

    public AttributeArgumentListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Arguments, closeParenToken);
    }

    public AttributeArgumentListSyntax AddArguments(params AttributeArgumentSyntax[] items)
    {
        return this.WithArguments(this.Arguments.AddRange(items));
    }
  }

  /// <summary>Attribute argument syntax.</summary>
  public sealed partial class AttributeArgumentSyntax : CSharpSyntaxNode
  {
    private NameEqualsSyntax nameEquals;
    private NameColonSyntax nameColon;
    private ExpressionSyntax expression;

    internal AttributeArgumentSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public NameEqualsSyntax NameEquals 
    {
        get
        {
            return this.GetRedAtZero(ref this.nameEquals);
        }
    }

    public NameColonSyntax NameColon 
    {
        get
        {
            return this.GetRed(ref this.nameColon, 1);
        }
    }

    /// <summary>Gets the expression.</summary>
    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.nameEquals);
            case 1: return this.GetRed(ref this.nameColon, 1);
            case 2: return this.GetRed(ref this.expression, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgument(this);
    }

    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AttributeArgument(nameEquals, nameColon, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AttributeArgumentSyntax WithNameEquals(NameEqualsSyntax nameEquals)
    {
        return this.Update(nameEquals, this.NameColon, this.Expression);
    }

    public AttributeArgumentSyntax WithNameColon(NameColonSyntax nameColon)
    {
        return this.Update(this.NameEquals, nameColon, this.Expression);
    }

    public AttributeArgumentSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.NameEquals, this.NameColon, expression);
    }
  }

  /// <summary>Class representing an identifier name followed by an equals token.</summary>
  public sealed partial class NameEqualsSyntax : CSharpSyntaxNode
  {
    private IdentifierNameSyntax name;

    internal NameEqualsSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the identifier name.</summary>
    public IdentifierNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NameEqualsSyntax)this.Green).equalsToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameEquals(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameEquals(this);
    }

    public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken)
        {
            var newNode = SyntaxFactory.NameEquals(name, equalsToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NameEqualsSyntax WithName(IdentifierNameSyntax name)
    {
        return this.Update(name, this.EqualsToken);
    }

    public NameEqualsSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken);
    }
  }

  /// <summary>Type parameter list syntax.</summary>
  public sealed partial class TypeParameterListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode parameters;

    internal TypeParameterListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the &lt; token.</summary>
    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeParameterListSyntax)this.Green).lessThanToken, this.Position, 0); }
    }

    /// <summary>Gets the parameter list.</summary>
    public SeparatedSyntaxList<TypeParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<TypeParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<TypeParameterSyntax>);
        }
    }

    /// <summary>Gets the &gt; token.</summary>
    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeParameterListSyntax)this.Green).greaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterList(this);
    }

    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterListSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Parameters, this.GreaterThanToken);
    }

    public TypeParameterListSyntax WithParameters(SeparatedSyntaxList<TypeParameterSyntax> parameters)
    {
        return this.Update(this.LessThanToken, parameters, this.GreaterThanToken);
    }

    public TypeParameterListSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Parameters, greaterThanToken);
    }

    public TypeParameterListSyntax AddParameters(params TypeParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>Type parameter syntax.</summary>
  public sealed partial class TypeParameterSyntax : CSharpSyntaxNode
  {
    private SyntaxNode attributeLists;

    internal TypeParameterSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public SyntaxToken VarianceKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeParameterSyntax)this.Green).varianceKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxToken);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeParameterSyntax)this.Green).identifier, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameter(this);
    }

    public TypeParameterSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
        if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.VarianceKeyword, this.Identifier);
    }

    public TypeParameterSyntax WithVarianceKeyword(SyntaxToken varianceKeyword)
    {
        return this.Update(this.AttributeLists, varianceKeyword, this.Identifier);
    }

    public TypeParameterSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.VarianceKeyword, identifier);
    }

    public TypeParameterSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
  }

  /// <summary>Base class for type declaration syntax.</summary>
  public abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseTypeDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeSyntax> AttributeLists { get; }
    public BaseTypeDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeListsCore(attributeLists);
    internal abstract BaseTypeDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists);

    public BaseTypeDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items) => AddAttributeListsCore(items);
    internal abstract BaseTypeDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items);

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }
    public BaseTypeDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) => WithModifiersCore(modifiers);
    internal abstract BaseTypeDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers);

    public BaseTypeDeclarationSyntax AddModifiers(params SyntaxToken[] items) => AddModifiersCore(items);
    internal abstract BaseTypeDeclarationSyntax AddModifiersCore(params SyntaxToken[] items);

    /// <summary>Gets the identifier.</summary>
    public abstract SyntaxToken Identifier { get; }
    public BaseTypeDeclarationSyntax WithIdentifier(SyntaxToken identifier) => WithIdentifierCore(identifier);
    internal abstract BaseTypeDeclarationSyntax WithIdentifierCore(SyntaxToken identifier);

    /// <summary>Gets the extends type list.</summary>
    public abstract ExtendListSyntax ExtendList { get; }
    public BaseTypeDeclarationSyntax WithExtendList(ExtendListSyntax extendList) => WithExtendListCore(extendList);
    internal abstract BaseTypeDeclarationSyntax WithExtendListCore(ExtendListSyntax extendList);

    public BaseTypeDeclarationSyntax AddExtendListTypes(params BaseTypeSyntax[] items) => AddExtendListTypesCore(items);
    internal abstract BaseTypeDeclarationSyntax AddExtendListTypesCore(params BaseTypeSyntax[] items);

    /// <summary>Gets the implements type list.</summary>
    public abstract ImplementListSyntax ImplementList { get; }
    public BaseTypeDeclarationSyntax WithImplementList(ImplementListSyntax implementList) => WithImplementListCore(implementList);
    internal abstract BaseTypeDeclarationSyntax WithImplementListCore(ImplementListSyntax implementList);

    public BaseTypeDeclarationSyntax AddImplementListTypes(params BaseTypeSyntax[] items) => AddImplementListTypesCore(items);
    internal abstract BaseTypeDeclarationSyntax AddImplementListTypesCore(params BaseTypeSyntax[] items);

    /// <summary>Gets the open brace token.</summary>
    public abstract SyntaxToken OpenBraceToken { get; }
    public BaseTypeDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => WithOpenBraceTokenCore(openBraceToken);
    internal abstract BaseTypeDeclarationSyntax WithOpenBraceTokenCore(SyntaxToken openBraceToken);

    /// <summary>Gets the close brace token.</summary>
    public abstract SyntaxToken CloseBraceToken { get; }
    public BaseTypeDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => WithCloseBraceTokenCore(closeBraceToken);
    internal abstract BaseTypeDeclarationSyntax WithCloseBraceTokenCore(SyntaxToken closeBraceToken);

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken EosToken { get; }
    public BaseTypeDeclarationSyntax WithEosToken(SyntaxToken eosToken) => WithEosTokenCore(eosToken);
    internal abstract BaseTypeDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken);
  }

  /// <summary>Base class for type declaration syntax (class, struct, interface).</summary>
  public abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal TypeDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
    public abstract SyntaxToken Keyword { get; }
    public TypeDeclarationSyntax WithKeyword(SyntaxToken keyword) => WithKeywordCore(keyword);
    internal abstract TypeDeclarationSyntax WithKeywordCore(SyntaxToken keyword);

    public abstract TypeParameterListSyntax TypeParameterList { get; }
    public TypeDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList) => WithTypeParameterListCore(typeParameterList);
    internal abstract TypeDeclarationSyntax WithTypeParameterListCore(TypeParameterListSyntax typeParameterList);

    public TypeDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items) => AddTypeParameterListParametersCore(items);
    internal abstract TypeDeclarationSyntax AddTypeParameterListParametersCore(params TypeParameterSyntax[] items);

    /// <summary>Gets the type constraint list.</summary>
    public abstract SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }
    public TypeDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) => WithConstraintClausesCore(constraintClauses);
    internal abstract TypeDeclarationSyntax WithConstraintClausesCore(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses);

    public TypeDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items) => AddConstraintClausesCore(items);
    internal abstract TypeDeclarationSyntax AddConstraintClausesCore(params TypeParameterConstraintClauseSyntax[] items);

    /// <summary>Gets the member declarations.</summary>
    public abstract SyntaxList<MemberDeclarationSyntax> Members { get; }
    public TypeDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members) => WithMembersCore(members);
    internal abstract TypeDeclarationSyntax WithMembersCore(SyntaxList<MemberDeclarationSyntax> members);

    public TypeDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items) => AddMembersCore(items);
    internal abstract TypeDeclarationSyntax AddMembersCore(params MemberDeclarationSyntax[] items);

    public new TypeDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists) => (TypeDeclarationSyntax)WithAttributeListsCore(attributeLists);
    public new TypeDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) => (TypeDeclarationSyntax)WithModifiersCore(modifiers);
    public new TypeDeclarationSyntax WithIdentifier(SyntaxToken identifier) => (TypeDeclarationSyntax)WithIdentifierCore(identifier);
    public new TypeDeclarationSyntax WithExtendList(ExtendListSyntax extendList) => (TypeDeclarationSyntax)WithExtendListCore(extendList);
    public new TypeDeclarationSyntax WithImplementList(ImplementListSyntax implementList) => (TypeDeclarationSyntax)WithImplementListCore(implementList);
    public new TypeDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken) => (TypeDeclarationSyntax)WithOpenBraceTokenCore(openBraceToken);
    public new TypeDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken) => (TypeDeclarationSyntax)WithCloseBraceTokenCore(closeBraceToken);
    public new TypeDeclarationSyntax WithEosToken(SyntaxToken eosToken) => (TypeDeclarationSyntax)WithEosTokenCore(eosToken);

    public new TypeDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items) => (TypeDeclarationSyntax)AddAttributeListsCore(items);

    public new TypeDeclarationSyntax AddModifiers(params SyntaxToken[] items) => (TypeDeclarationSyntax)AddModifiersCore(items);

    public new BaseTypeDeclarationSyntax AddExtendListTypes(params BaseTypeSyntax[] items) => AddExtendListTypesCore(items);

    public new BaseTypeDeclarationSyntax AddImplementListTypes(params BaseTypeSyntax[] items) => AddImplementListTypesCore(items);
  }

  /// <summary>Module declaration syntax.</summary>
  public sealed partial class ModuleDeclarationSyntax : TypeDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private ExtendListSyntax extendList;
    private ImplementListSyntax implementList;
    private SyntaxNode constraintClauses;
    private SyntaxNode members;

    internal ModuleDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the class keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ModuleDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ModuleDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 4);
        }
    }

    public override ExtendListSyntax ExtendList 
    {
        get
        {
            return this.GetRed(ref this.extendList, 5);
        }
    }

    public override ImplementListSyntax ImplementList 
    {
        get
        {
            return this.GetRed(ref this.implementList, 6);
        }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 7));
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ModuleDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(8), this.GetChildIndex(8)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 9));
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ModuleDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(10), this.GetChildIndex(10)); }
    }

    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ModuleDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(11), this.GetChildIndex(11));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.extendList, 5);
            case 6: return this.GetRed(ref this.implementList, 6);
            case 7: return this.GetRed(ref this.constraintClauses, 7);
            case 9: return this.GetRed(ref this.members, 9);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.typeParameterList;
            case 5: return this.extendList;
            case 6: return this.implementList;
            case 7: return this.constraintClauses;
            case 9: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitModuleDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitModuleDeclaration(this);
    }

    public ModuleDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ExtendListSyntax extendList, ImplementListSyntax implementList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || extendList != this.ExtendList || implementList != this.ImplementList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ModuleDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, extendList, implementList, constraintClauses, openBraceToken, members, closeBraceToken, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseTypeDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new ModuleDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new ModuleDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithKeywordCore(SyntaxToken keyword) => WithKeyword(keyword);
    public new ModuleDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
    public new ModuleDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithTypeParameterListCore(TypeParameterListSyntax typeParameterList) => WithTypeParameterList(typeParameterList);
    public new ModuleDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithExtendListCore(ExtendListSyntax extendList) => WithExtendList(extendList);
    public new ModuleDeclarationSyntax WithExtendList(ExtendListSyntax extendList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, extendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithImplementListCore(ImplementListSyntax implementList) => WithImplementList(implementList);
    public new ModuleDeclarationSyntax WithImplementList(ImplementListSyntax implementList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, implementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithConstraintClausesCore(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) => WithConstraintClauses(constraintClauses);
    public new ModuleDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithOpenBraceTokenCore(SyntaxToken openBraceToken) => WithOpenBraceToken(openBraceToken);
    public new ModuleDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithMembersCore(SyntaxList<MemberDeclarationSyntax> members) => WithMembers(members);
    public new ModuleDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithCloseBraceTokenCore(SyntaxToken closeBraceToken) => WithCloseBraceToken(closeBraceToken);
    public new ModuleDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new ModuleDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, eosToken);
    }
    internal override BaseTypeDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new ModuleDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseTypeDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new ModuleDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override TypeDeclarationSyntax AddTypeParameterListParametersCore(params TypeParameterSyntax[] items) => AddTypeParameterListParameters(items);

    public new ModuleDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddExtendListTypesCore(params BaseTypeSyntax[] items) => AddExtendListTypes(items);

    public new ModuleDeclarationSyntax AddExtendListTypes(params BaseTypeSyntax[] items)
    {
        var extendList = this.ExtendList ?? SyntaxFactory.ExtendList();
        return this.WithExtendList(extendList.WithTypes(extendList.Types.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddImplementListTypesCore(params BaseTypeSyntax[] items) => AddImplementListTypes(items);

    public new ModuleDeclarationSyntax AddImplementListTypes(params BaseTypeSyntax[] items)
    {
        var implementList = this.ImplementList ?? SyntaxFactory.ImplementList();
        return this.WithImplementList(implementList.WithTypes(implementList.Types.AddRange(items)));
    }
    internal override TypeDeclarationSyntax AddConstraintClausesCore(params TypeParameterConstraintClauseSyntax[] items) => AddConstraintClauses(items);

    public new ModuleDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }
    internal override TypeDeclarationSyntax AddMembersCore(params MemberDeclarationSyntax[] items) => AddMembers(items);

    public new ModuleDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Class type declaration syntax.</summary>
  public sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private ExtendListSyntax extendList;
    private ImplementListSyntax implementList;
    private SyntaxNode constraintClauses;
    private SyntaxNode members;

    internal ClassDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the class keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 4);
        }
    }

    public override ExtendListSyntax ExtendList 
    {
        get
        {
            return this.GetRed(ref this.extendList, 5);
        }
    }

    public override ImplementListSyntax ImplementList 
    {
        get
        {
            return this.GetRed(ref this.implementList, 6);
        }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 7));
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(8), this.GetChildIndex(8)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 9));
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(10), this.GetChildIndex(10)); }
    }

    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ClassDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(11), this.GetChildIndex(11));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.extendList, 5);
            case 6: return this.GetRed(ref this.implementList, 6);
            case 7: return this.GetRed(ref this.constraintClauses, 7);
            case 9: return this.GetRed(ref this.members, 9);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.typeParameterList;
            case 5: return this.extendList;
            case 6: return this.implementList;
            case 7: return this.constraintClauses;
            case 9: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitClassDeclaration(this);
    }

    public ClassDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ExtendListSyntax extendList, ImplementListSyntax implementList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || extendList != this.ExtendList || implementList != this.ImplementList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ClassDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, extendList, implementList, constraintClauses, openBraceToken, members, closeBraceToken, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseTypeDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new ClassDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new ClassDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithKeywordCore(SyntaxToken keyword) => WithKeyword(keyword);
    public new ClassDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
    public new ClassDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithTypeParameterListCore(TypeParameterListSyntax typeParameterList) => WithTypeParameterList(typeParameterList);
    public new ClassDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithExtendListCore(ExtendListSyntax extendList) => WithExtendList(extendList);
    public new ClassDeclarationSyntax WithExtendList(ExtendListSyntax extendList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, extendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithImplementListCore(ImplementListSyntax implementList) => WithImplementList(implementList);
    public new ClassDeclarationSyntax WithImplementList(ImplementListSyntax implementList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, implementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithConstraintClausesCore(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) => WithConstraintClauses(constraintClauses);
    public new ClassDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithOpenBraceTokenCore(SyntaxToken openBraceToken) => WithOpenBraceToken(openBraceToken);
    public new ClassDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithMembersCore(SyntaxList<MemberDeclarationSyntax> members) => WithMembers(members);
    public new ClassDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithCloseBraceTokenCore(SyntaxToken closeBraceToken) => WithCloseBraceToken(closeBraceToken);
    public new ClassDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new ClassDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, eosToken);
    }
    internal override BaseTypeDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new ClassDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseTypeDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new ClassDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override TypeDeclarationSyntax AddTypeParameterListParametersCore(params TypeParameterSyntax[] items) => AddTypeParameterListParameters(items);

    public new ClassDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddExtendListTypesCore(params BaseTypeSyntax[] items) => AddExtendListTypes(items);

    public new ClassDeclarationSyntax AddExtendListTypes(params BaseTypeSyntax[] items)
    {
        var extendList = this.ExtendList ?? SyntaxFactory.ExtendList();
        return this.WithExtendList(extendList.WithTypes(extendList.Types.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddImplementListTypesCore(params BaseTypeSyntax[] items) => AddImplementListTypes(items);

    public new ClassDeclarationSyntax AddImplementListTypes(params BaseTypeSyntax[] items)
    {
        var implementList = this.ImplementList ?? SyntaxFactory.ImplementList();
        return this.WithImplementList(implementList.WithTypes(implementList.Types.AddRange(items)));
    }
    internal override TypeDeclarationSyntax AddConstraintClausesCore(params TypeParameterConstraintClauseSyntax[] items) => AddConstraintClauses(items);

    public new ClassDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }
    internal override TypeDeclarationSyntax AddMembersCore(params MemberDeclarationSyntax[] items) => AddMembers(items);

    public new ClassDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Struct type declaration syntax.</summary>
  public sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private ExtendListSyntax extendList;
    private ImplementListSyntax implementList;
    private SyntaxNode constraintClauses;
    private SyntaxNode members;

    internal StructDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the struct keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 4);
        }
    }

    public override ExtendListSyntax ExtendList 
    {
        get
        {
            return this.GetRed(ref this.extendList, 5);
        }
    }

    public override ImplementListSyntax ImplementList 
    {
        get
        {
            return this.GetRed(ref this.implementList, 6);
        }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 7));
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(8), this.GetChildIndex(8)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 9));
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(10), this.GetChildIndex(10)); }
    }

    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.StructDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(11), this.GetChildIndex(11));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.extendList, 5);
            case 6: return this.GetRed(ref this.implementList, 6);
            case 7: return this.GetRed(ref this.constraintClauses, 7);
            case 9: return this.GetRed(ref this.members, 9);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.typeParameterList;
            case 5: return this.extendList;
            case 6: return this.implementList;
            case 7: return this.constraintClauses;
            case 9: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStructDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitStructDeclaration(this);
    }

    public StructDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ExtendListSyntax extendList, ImplementListSyntax implementList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || extendList != this.ExtendList || implementList != this.ImplementList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.StructDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, extendList, implementList, constraintClauses, openBraceToken, members, closeBraceToken, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseTypeDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new StructDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new StructDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithKeywordCore(SyntaxToken keyword) => WithKeyword(keyword);
    public new StructDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
    public new StructDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithTypeParameterListCore(TypeParameterListSyntax typeParameterList) => WithTypeParameterList(typeParameterList);
    public new StructDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithExtendListCore(ExtendListSyntax extendList) => WithExtendList(extendList);
    public new StructDeclarationSyntax WithExtendList(ExtendListSyntax extendList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, extendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithImplementListCore(ImplementListSyntax implementList) => WithImplementList(implementList);
    public new StructDeclarationSyntax WithImplementList(ImplementListSyntax implementList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, implementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithConstraintClausesCore(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) => WithConstraintClauses(constraintClauses);
    public new StructDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithOpenBraceTokenCore(SyntaxToken openBraceToken) => WithOpenBraceToken(openBraceToken);
    public new StructDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithMembersCore(SyntaxList<MemberDeclarationSyntax> members) => WithMembers(members);
    public new StructDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithCloseBraceTokenCore(SyntaxToken closeBraceToken) => WithCloseBraceToken(closeBraceToken);
    public new StructDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new StructDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, eosToken);
    }
    internal override BaseTypeDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new StructDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseTypeDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new StructDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override TypeDeclarationSyntax AddTypeParameterListParametersCore(params TypeParameterSyntax[] items) => AddTypeParameterListParameters(items);

    public new StructDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddExtendListTypesCore(params BaseTypeSyntax[] items) => AddExtendListTypes(items);

    public new StructDeclarationSyntax AddExtendListTypes(params BaseTypeSyntax[] items)
    {
        var extendList = this.ExtendList ?? SyntaxFactory.ExtendList();
        return this.WithExtendList(extendList.WithTypes(extendList.Types.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddImplementListTypesCore(params BaseTypeSyntax[] items) => AddImplementListTypes(items);

    public new StructDeclarationSyntax AddImplementListTypes(params BaseTypeSyntax[] items)
    {
        var implementList = this.ImplementList ?? SyntaxFactory.ImplementList();
        return this.WithImplementList(implementList.WithTypes(implementList.Types.AddRange(items)));
    }
    internal override TypeDeclarationSyntax AddConstraintClausesCore(params TypeParameterConstraintClauseSyntax[] items) => AddConstraintClauses(items);

    public new StructDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }
    internal override TypeDeclarationSyntax AddMembersCore(params MemberDeclarationSyntax[] items) => AddMembers(items);

    public new StructDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Interface type declaration syntax.</summary>
  public sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeParameterListSyntax typeParameterList;
    private ExtendListSyntax extendList;
    private ImplementListSyntax implementList;
    private SyntaxNode constraintClauses;
    private SyntaxNode members;

    internal InterfaceDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the interface keyword token.</summary>
    public override SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 4);
        }
    }

    public override ExtendListSyntax ExtendList 
    {
        get
        {
            return this.GetRed(ref this.extendList, 5);
        }
    }

    public override ImplementListSyntax ImplementList 
    {
        get
        {
            return this.GetRed(ref this.implementList, 6);
        }
    }

    public override SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 7));
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(8), this.GetChildIndex(8)); }
    }

    public override SyntaxList<MemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<MemberDeclarationSyntax>(this.GetRed(ref this.members, 9));
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(10), this.GetChildIndex(10)); }
    }

    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.InterfaceDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(11), this.GetChildIndex(11));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.typeParameterList, 4);
            case 5: return this.GetRed(ref this.extendList, 5);
            case 6: return this.GetRed(ref this.implementList, 6);
            case 7: return this.GetRed(ref this.constraintClauses, 7);
            case 9: return this.GetRed(ref this.members, 9);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.typeParameterList;
            case 5: return this.extendList;
            case 6: return this.implementList;
            case 7: return this.constraintClauses;
            case 9: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterfaceDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterfaceDeclaration(this);
    }

    public InterfaceDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ExtendListSyntax extendList, ImplementListSyntax implementList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || extendList != this.ExtendList || implementList != this.ImplementList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, extendList, implementList, constraintClauses, openBraceToken, members, closeBraceToken, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseTypeDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new InterfaceDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new InterfaceDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithKeywordCore(SyntaxToken keyword) => WithKeyword(keyword);
    public new InterfaceDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
    public new InterfaceDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithTypeParameterListCore(TypeParameterListSyntax typeParameterList) => WithTypeParameterList(typeParameterList);
    public new InterfaceDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, typeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithExtendListCore(ExtendListSyntax extendList) => WithExtendList(extendList);
    public new InterfaceDeclarationSyntax WithExtendList(ExtendListSyntax extendList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, extendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithImplementListCore(ImplementListSyntax implementList) => WithImplementList(implementList);
    public new InterfaceDeclarationSyntax WithImplementList(ImplementListSyntax implementList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, implementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithConstraintClausesCore(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses) => WithConstraintClauses(constraintClauses);
    public new InterfaceDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, constraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithOpenBraceTokenCore(SyntaxToken openBraceToken) => WithOpenBraceToken(openBraceToken);
    public new InterfaceDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, openBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override TypeDeclarationSyntax WithMembersCore(SyntaxList<MemberDeclarationSyntax> members) => WithMembers(members);
    public new InterfaceDeclarationSyntax WithMembers(SyntaxList<MemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithCloseBraceTokenCore(SyntaxToken closeBraceToken) => WithCloseBraceToken(closeBraceToken);
    public new InterfaceDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, closeBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new InterfaceDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Identifier, this.TypeParameterList, this.ExtendList, this.ImplementList, this.ConstraintClauses, this.OpenBraceToken, this.Members, this.CloseBraceToken, eosToken);
    }
    internal override BaseTypeDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new InterfaceDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseTypeDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new InterfaceDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override TypeDeclarationSyntax AddTypeParameterListParametersCore(params TypeParameterSyntax[] items) => AddTypeParameterListParameters(items);

    public new InterfaceDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddExtendListTypesCore(params BaseTypeSyntax[] items) => AddExtendListTypes(items);

    public new InterfaceDeclarationSyntax AddExtendListTypes(params BaseTypeSyntax[] items)
    {
        var extendList = this.ExtendList ?? SyntaxFactory.ExtendList();
        return this.WithExtendList(extendList.WithTypes(extendList.Types.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddImplementListTypesCore(params BaseTypeSyntax[] items) => AddImplementListTypes(items);

    public new InterfaceDeclarationSyntax AddImplementListTypes(params BaseTypeSyntax[] items)
    {
        var implementList = this.ImplementList ?? SyntaxFactory.ImplementList();
        return this.WithImplementList(implementList.WithTypes(implementList.Types.AddRange(items)));
    }
    internal override TypeDeclarationSyntax AddConstraintClausesCore(params TypeParameterConstraintClauseSyntax[] items) => AddConstraintClauses(items);

    public new InterfaceDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }
    internal override TypeDeclarationSyntax AddMembersCore(params MemberDeclarationSyntax[] items) => AddMembers(items);

    public new InterfaceDeclarationSyntax AddMembers(params MemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Enum type declaration syntax.</summary>
  public sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private ExtendListSyntax extendList;
    private ImplementListSyntax implementList;
    private SyntaxNode members;

    internal EnumDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the enum keyword token.</summary>
    public SyntaxToken EnumKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).enumKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override ExtendListSyntax ExtendList 
    {
        get
        {
            return this.GetRed(ref this.extendList, 4);
        }
    }

    public override ImplementListSyntax ImplementList 
    {
        get
        {
            return this.GetRed(ref this.implementList, 5);
        }
    }

    public override SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).openBraceToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    /// <summary>Gets the members declaration list.</summary>
    public SyntaxList<EnumMemberDeclarationSyntax> Members 
    {
        get
        {
            return new SyntaxList<EnumMemberDeclarationSyntax>(this.GetRed(ref this.members, 7));
        }
    }

    public override SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).closeBraceToken, this.GetChildPosition(8), this.GetChildIndex(8)); }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EnumDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(9), this.GetChildIndex(9));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.extendList, 4);
            case 5: return this.GetRed(ref this.implementList, 5);
            case 7: return this.GetRed(ref this.members, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.extendList;
            case 5: return this.implementList;
            case 7: return this.members;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEnumDeclaration(this);
    }

    public EnumDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, ExtendListSyntax extendList, ImplementListSyntax implementList, SyntaxToken openBraceToken, SyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || extendList != this.ExtendList || implementList != this.ImplementList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.EnumDeclaration(attributeLists, modifiers, enumKeyword, identifier, extendList, implementList, openBraceToken, members, closeBraceToken, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseTypeDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new EnumDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.ExtendList, this.ImplementList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new EnumDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.EnumKeyword, this.Identifier, this.ExtendList, this.ImplementList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    public EnumDeclarationSyntax WithEnumKeyword(SyntaxToken enumKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, enumKeyword, this.Identifier, this.ExtendList, this.ImplementList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithIdentifierCore(SyntaxToken identifier) => WithIdentifier(identifier);
    public new EnumDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, identifier, this.ExtendList, this.ImplementList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithExtendListCore(ExtendListSyntax extendList) => WithExtendList(extendList);
    public new EnumDeclarationSyntax WithExtendList(ExtendListSyntax extendList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, extendList, this.ImplementList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithImplementListCore(ImplementListSyntax implementList) => WithImplementList(implementList);
    public new EnumDeclarationSyntax WithImplementList(ImplementListSyntax implementList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.ExtendList, implementList, this.OpenBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithOpenBraceTokenCore(SyntaxToken openBraceToken) => WithOpenBraceToken(openBraceToken);
    public new EnumDeclarationSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.ExtendList, this.ImplementList, openBraceToken, this.Members, this.CloseBraceToken, this.EosToken);
    }

    public EnumDeclarationSyntax WithMembers(SyntaxList<EnumMemberDeclarationSyntax> members)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.ExtendList, this.ImplementList, this.OpenBraceToken, members, this.CloseBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithCloseBraceTokenCore(SyntaxToken closeBraceToken) => WithCloseBraceToken(closeBraceToken);
    public new EnumDeclarationSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.ExtendList, this.ImplementList, this.OpenBraceToken, this.Members, closeBraceToken, this.EosToken);
    }

    internal override BaseTypeDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new EnumDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EnumKeyword, this.Identifier, this.ExtendList, this.ImplementList, this.OpenBraceToken, this.Members, this.CloseBraceToken, eosToken);
    }
    internal override BaseTypeDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new EnumDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseTypeDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new EnumDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override BaseTypeDeclarationSyntax AddExtendListTypesCore(params BaseTypeSyntax[] items) => AddExtendListTypes(items);

    public new EnumDeclarationSyntax AddExtendListTypes(params BaseTypeSyntax[] items)
    {
        var extendList = this.ExtendList ?? SyntaxFactory.ExtendList();
        return this.WithExtendList(extendList.WithTypes(extendList.Types.AddRange(items)));
    }
    internal override BaseTypeDeclarationSyntax AddImplementListTypesCore(params BaseTypeSyntax[] items) => AddImplementListTypes(items);

    public new EnumDeclarationSyntax AddImplementListTypes(params BaseTypeSyntax[] items)
    {
        var implementList = this.ImplementList ?? SyntaxFactory.ImplementList();
        return this.WithImplementList(implementList.WithTypes(implementList.Types.AddRange(items)));
    }

    public EnumDeclarationSyntax AddMembers(params EnumMemberDeclarationSyntax[] items)
    {
        return this.WithMembers(this.Members.AddRange(items));
    }
  }

  /// <summary>Delegate declaration syntax.</summary>
  public sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeSyntax returnType;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private SyntaxNode constraintClauses;

    internal DelegateDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the "delegate" keyword.</summary>
    public SyntaxToken DelegateKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DelegateDeclarationSyntax)this.Green).delegateKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType 
    {
        get
        {
            return this.GetRed(ref this.returnType, 3);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DelegateDeclarationSyntax)this.Green).identifier, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 5);
        }
    }

    /// <summary>Gets the parameter list.</summary>
    public ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 6);
        }
    }

    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 7));
        }
    }

    /// <summary>Gets the semicolon token.</summary>
    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DelegateDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(8), this.GetChildIndex(8));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.returnType, 3);
            case 5: return this.GetRed(ref this.typeParameterList, 5);
            case 6: return this.GetRed(ref this.parameterList, 6);
            case 7: return this.GetRed(ref this.constraintClauses, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.returnType;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDelegateDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDelegateDeclaration(this);
    }

    public DelegateDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DelegateDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.EosToken);
    }

    public DelegateDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.EosToken);
    }

    public DelegateDeclarationSyntax WithDelegateKeyword(SyntaxToken delegateKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, delegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.EosToken);
    }

    public DelegateDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, returnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.EosToken);
    }

    public DelegateDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.ReturnType, identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, this.EosToken);
    }

    public DelegateDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, typeParameterList, this.ParameterList, this.ConstraintClauses, this.EosToken);
    }

    public DelegateDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, parameterList, this.ConstraintClauses, this.EosToken);
    }

    public DelegateDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, constraintClauses, this.EosToken);
    }

    public DelegateDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.DelegateKeyword, this.ReturnType, this.Identifier, this.TypeParameterList, this.ParameterList, this.ConstraintClauses, eosToken);
    }

    public DelegateDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public DelegateDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public DelegateDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }

    public DelegateDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public DelegateDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }
  }

  public sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private EqualsValueClauseSyntax equalsValue;

    internal EnumMemberDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EnumMemberDeclarationSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public EqualsValueClauseSyntax EqualsValue 
    {
        get
        {
            return this.GetRed(ref this.equalsValue, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 2: return this.GetRed(ref this.equalsValue, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 2: return this.equalsValue;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumMemberDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEnumMemberDeclaration(this);
    }

    public EnumMemberDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
        if (attributeLists != this.AttributeLists || identifier != this.Identifier || equalsValue != this.EqualsValue)
        {
            var newNode = SyntaxFactory.EnumMemberDeclaration(attributeLists, identifier, equalsValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public EnumMemberDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Identifier, this.EqualsValue);
    }

    public EnumMemberDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, identifier, this.EqualsValue);
    }

    public EnumMemberDeclarationSyntax WithEqualsValue(EqualsValueClauseSyntax equalsValue)
    {
        return this.Update(this.AttributeLists, this.Identifier, equalsValue);
    }

    public EnumMemberDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
  }

  /// <summary>Provides the base for an extends or implements list. This is an abstract class.</summary>
  public abstract partial class BaseListSyntax : CSharpSyntaxNode
  {
    internal BaseListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>SeparatedSyntaxList of types.</summary>
    public abstract SeparatedSyntaxList<BaseTypeSyntax> Types { get; }
    public BaseListSyntax WithTypes(SeparatedSyntaxList<BaseTypeSyntax> types) => WithTypesCore(types);
    internal abstract BaseListSyntax WithTypesCore(SeparatedSyntaxList<BaseTypeSyntax> types);

    public BaseListSyntax AddTypes(params BaseTypeSyntax[] items) => AddTypesCore(items);
    internal abstract BaseListSyntax AddTypesCore(params BaseTypeSyntax[] items);
  }

  /// <summary>Extends list syntax.</summary>
  public sealed partial class ExtendListSyntax : BaseListSyntax
  {
    private SyntaxNode types;

    internal ExtendListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the extends keyword.</summary>
    public SyntaxToken ExtendsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ExtendListSyntax)this.Green).extendsKeyword, this.Position, 0); }
    }

    /// <summary>Gets the base type references.</summary>
    public override SeparatedSyntaxList<BaseTypeSyntax> Types 
    {
        get
        {
            var red = this.GetRed(ref this.types, 1);
            if (red != null)
                return new SeparatedSyntaxList<BaseTypeSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<BaseTypeSyntax>);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.types, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.types;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExtendList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExtendList(this);
    }

    public ExtendListSyntax Update(SyntaxToken extendsKeyword, SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        if (extendsKeyword != this.ExtendsKeyword || types != this.Types)
        {
            var newNode = SyntaxFactory.ExtendList(extendsKeyword, types);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExtendListSyntax WithExtendsKeyword(SyntaxToken extendsKeyword)
    {
        return this.Update(extendsKeyword, this.Types);
    }

    internal override BaseListSyntax WithTypesCore(SeparatedSyntaxList<BaseTypeSyntax> types) => WithTypes(types);
    public new ExtendListSyntax WithTypes(SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        return this.Update(this.ExtendsKeyword, types);
    }
    internal override BaseListSyntax AddTypesCore(params BaseTypeSyntax[] items) => AddTypes(items);

    public new ExtendListSyntax AddTypes(params BaseTypeSyntax[] items)
    {
        return this.WithTypes(this.Types.AddRange(items));
    }
  }

  /// <summary>Implements list syntax.</summary>
  public sealed partial class ImplementListSyntax : BaseListSyntax
  {
    private SyntaxNode types;

    internal ImplementListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the implements keyword.</summary>
    public SyntaxToken ImplementsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ImplementListSyntax)this.Green).implementsKeyword, this.Position, 0); }
    }

    /// <summary>Gets the implemented interfaces references.</summary>
    public override SeparatedSyntaxList<BaseTypeSyntax> Types 
    {
        get
        {
            var red = this.GetRed(ref this.types, 1);
            if (red != null)
                return new SeparatedSyntaxList<BaseTypeSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<BaseTypeSyntax>);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.types, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.types;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplementList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplementList(this);
    }

    public ImplementListSyntax Update(SyntaxToken implementsKeyword, SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        if (implementsKeyword != this.ImplementsKeyword || types != this.Types)
        {
            var newNode = SyntaxFactory.ImplementList(implementsKeyword, types);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ImplementListSyntax WithImplementsKeyword(SyntaxToken implementsKeyword)
    {
        return this.Update(implementsKeyword, this.Types);
    }

    internal override BaseListSyntax WithTypesCore(SeparatedSyntaxList<BaseTypeSyntax> types) => WithTypes(types);
    public new ImplementListSyntax WithTypes(SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        return this.Update(this.ImplementsKeyword, types);
    }
    internal override BaseListSyntax AddTypesCore(params BaseTypeSyntax[] items) => AddTypes(items);

    public new ImplementListSyntax AddTypes(params BaseTypeSyntax[] items)
    {
        return this.WithTypes(this.Types.AddRange(items));
    }
  }

  /// <summary>Extends list syntax.</summary>
  public sealed partial class ThrowsListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode types;

    internal ThrowsListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the extends keyword.</summary>
    public SyntaxToken ThrowsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ThrowsListSyntax)this.Green).throwsKeyword, this.Position, 0); }
    }

    /// <summary>Gets the base type references.</summary>
    public SeparatedSyntaxList<TypeSyntax> Types 
    {
        get
        {
            var red = this.GetRed(ref this.types, 1);
            if (red != null)
                return new SeparatedSyntaxList<TypeSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<TypeSyntax>);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.types, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.types;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowsList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThrowsList(this);
    }

    public ThrowsListSyntax Update(SyntaxToken throwsKeyword, SeparatedSyntaxList<TypeSyntax> types)
    {
        if (throwsKeyword != this.ThrowsKeyword || types != this.Types)
        {
            var newNode = SyntaxFactory.ThrowsList(throwsKeyword, types);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ThrowsListSyntax WithThrowsKeyword(SyntaxToken throwsKeyword)
    {
        return this.Update(throwsKeyword, this.Types);
    }

    public ThrowsListSyntax WithTypes(SeparatedSyntaxList<TypeSyntax> types)
    {
        return this.Update(this.ThrowsKeyword, types);
    }

    public ThrowsListSyntax AddTypes(params TypeSyntax[] items)
    {
        return this.WithTypes(this.Types.AddRange(items));
    }
  }

  /// <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
  public abstract partial class BaseTypeSyntax : CSharpSyntaxNode
  {
    internal BaseTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract TypeSyntax Type { get; }
    public BaseTypeSyntax WithType(TypeSyntax type) => WithTypeCore(type);
    internal abstract BaseTypeSyntax WithTypeCore(TypeSyntax type);
  }

  public sealed partial class SimpleBaseTypeSyntax : BaseTypeSyntax
  {
    private TypeSyntax type;

    internal SimpleBaseTypeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleBaseType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleBaseType(this);
    }

    public SimpleBaseTypeSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.SimpleBaseType(type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseTypeSyntax WithTypeCore(TypeSyntax type) => WithType(type);
    public new SimpleBaseTypeSyntax WithType(TypeSyntax type)
    {
        return this.Update(type);
    }
  }

  /// <summary>Contract - requires or ensures - clause.</summary>
  public sealed partial class ContractClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax condition;

    internal ContractClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the requires or ensures contract keyword.</summary>
    public SyntaxToken ContractKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ContractClauseSyntax)this.Green).contractKeyword, this.Position, 0); }
    }

    /// <summary>Gets the condition expression used by this contract.</summary>
    public ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.condition, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitContractClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitContractClause(this);
    }

    public ContractClauseSyntax Update(SyntaxToken contractKeyword, ExpressionSyntax condition)
    {
        if (contractKeyword != this.ContractKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.ContractClause(contractKeyword, condition);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ContractClauseSyntax WithContractKeyword(SyntaxToken contractKeyword)
    {
        return this.Update(contractKeyword, this.Condition);
    }

    public ContractClauseSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.ContractKeyword, condition);
    }
  }

  /// <summary>Type parameter constraint clause.</summary>
  public sealed partial class TypeParameterConstraintClauseSyntax : CSharpSyntaxNode
  {
    private IdentifierNameSyntax name;
    private SyntaxNode constraints;

    internal TypeParameterConstraintClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken WhereKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax)this.Green).whereKeyword, this.Position, 0); }
    }

    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax)this.Green).colonToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the constraints list.</summary>
    public SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints 
    {
        get
        {
            var red = this.GetRed(ref this.constraints, 3);
            if (red != null)
                return new SeparatedSyntaxList<TypeParameterConstraintSyntax>(red, this.GetChildIndex(3));

            return default(SeparatedSyntaxList<TypeParameterConstraintSyntax>);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 3: return this.GetRed(ref this.constraints, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 3: return this.constraints;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterConstraintClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterConstraintClause(this);
    }

    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        if (whereKeyword != this.WhereKeyword || name != this.Name || colonToken != this.ColonToken || constraints != this.Constraints)
        {
            var newNode = SyntaxFactory.TypeParameterConstraintClause(whereKeyword, name, colonToken, constraints);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeParameterConstraintClauseSyntax WithWhereKeyword(SyntaxToken whereKeyword)
    {
        return this.Update(whereKeyword, this.Name, this.ColonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithName(IdentifierNameSyntax name)
    {
        return this.Update(this.WhereKeyword, name, this.ColonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.WhereKeyword, this.Name, colonToken, this.Constraints);
    }

    public TypeParameterConstraintClauseSyntax WithConstraints(SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        return this.Update(this.WhereKeyword, this.Name, this.ColonToken, constraints);
    }

    public TypeParameterConstraintClauseSyntax AddConstraints(params TypeParameterConstraintSyntax[] items)
    {
        return this.WithConstraints(this.Constraints.AddRange(items));
    }
  }

  /// <summary>Base type for type parameter constraint syntax.</summary>
  public abstract partial class TypeParameterConstraintSyntax : CSharpSyntaxNode
  {
    internal TypeParameterConstraintSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>Constructor constraint syntax.</summary>
  public sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal ConstructorConstraintSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the "new" keyword.</summary>
    public SyntaxToken NewKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstructorConstraintSyntax)this.Green).newKeyword, this.Position, 0); }
    }

    /// <summary>Gets the open paren keyword.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstructorConstraintSyntax)this.Green).openParenToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the close paren keyword.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstructorConstraintSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorConstraint(this);
    }

    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
        if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstructorConstraintSyntax WithNewKeyword(SyntaxToken newKeyword)
    {
        return this.Update(newKeyword, this.OpenParenToken, this.CloseParenToken);
    }

    public ConstructorConstraintSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(this.NewKeyword, openParenToken, this.CloseParenToken);
    }

    public ConstructorConstraintSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.NewKeyword, this.OpenParenToken, closeParenToken);
    }
  }

  /// <summary>Base type for class or struct constraint syntax.</summary>
  public sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal ClassOrStructConstraintSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the is keyword .</summary>
    public SyntaxToken IsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ClassOrStructConstraintSyntax)this.Green).isKeyword, this.Position, 0); }
    }

    /// <summary>Gets the constraint keyword ("class" or "struct").</summary>
    public SyntaxToken ClassOrStructKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ClassOrStructConstraintSyntax)this.Green).classOrStructKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ClassOrStructConstraintSyntax)this.Green).questionToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassOrStructConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitClassOrStructConstraint(this);
    }

    public ClassOrStructConstraintSyntax Update(SyntaxToken isKeyword, SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
    {
        if (isKeyword != this.IsKeyword || classOrStructKeyword != this.ClassOrStructKeyword || questionToken != this.QuestionToken)
        {
            var newNode = SyntaxFactory.ClassOrStructConstraint(this.Kind(), isKeyword, classOrStructKeyword, questionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ClassOrStructConstraintSyntax WithIsKeyword(SyntaxToken isKeyword)
    {
        return this.Update(isKeyword, this.ClassOrStructKeyword, this.QuestionToken);
    }

    public ClassOrStructConstraintSyntax WithClassOrStructKeyword(SyntaxToken classOrStructKeyword)
    {
        return this.Update(this.IsKeyword, classOrStructKeyword, this.QuestionToken);
    }

    public ClassOrStructConstraintSyntax WithQuestionToken(SyntaxToken questionToken)
    {
        return this.Update(this.IsKeyword, this.ClassOrStructKeyword, questionToken);
    }
  }

  /// <summary>Const constraint syntax.</summary>
  public sealed partial class ConstConstraintSyntax : TypeConstraintSyntax
  {
    private TypeSyntax type;

    internal ConstConstraintSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the is keyword .</summary>
    public SyntaxToken IsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstConstraintSyntax)this.Green).isKeyword, this.Position, 0); }
    }

    /// <summary>Gets the "const" keyword .</summary>
    public SyntaxToken ConstKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstConstraintSyntax)this.Green).constKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Get the type of the const constraint.</summary>
    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstConstraint(this);
    }

    public ConstConstraintSyntax Update(SyntaxToken isKeyword, SyntaxToken constKeyword, TypeSyntax type)
    {
        if (isKeyword != this.IsKeyword || constKeyword != this.ConstKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.ConstConstraint(isKeyword, constKeyword, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstConstraintSyntax WithIsKeyword(SyntaxToken isKeyword)
    {
        return this.Update(isKeyword, this.ConstKeyword, this.Type);
    }

    public ConstConstraintSyntax WithConstKeyword(SyntaxToken constKeyword)
    {
        return this.Update(this.IsKeyword, constKeyword, this.Type);
    }

    internal override TypeConstraintSyntax WithTypeCore(TypeSyntax type) => WithType(type);
    public new ConstConstraintSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.IsKeyword, this.ConstKeyword, type);
    }
  }

  /// <summary>Type constraint syntax.</summary>
  public abstract partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal TypeConstraintSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the type syntax.</summary>
    public abstract TypeSyntax Type { get; }
    public TypeConstraintSyntax WithType(TypeSyntax type) => WithTypeCore(type);
    internal abstract TypeConstraintSyntax WithTypeCore(TypeSyntax type);
  }

  /// <summary>Type constraint syntax.</summary>
  public sealed partial class ExtendsOrImplementsTypeConstraintSyntax : TypeConstraintSyntax
  {
    private TypeSyntax type;

    internal ExtendsOrImplementsTypeConstraintSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the extends or implements keyword ("extends" or "implements").</summary>
    public SyntaxToken ExtendsOrImplementsKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ExtendsOrImplementsTypeConstraintSyntax)this.Green).extendsOrImplementsKeyword, this.Position, 0); }
    }

    /// <summary>Gets the type syntax.</summary>
    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExtendsOrImplementsTypeConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExtendsOrImplementsTypeConstraint(this);
    }

    public ExtendsOrImplementsTypeConstraintSyntax Update(SyntaxToken extendsOrImplementsKeyword, TypeSyntax type)
    {
        if (extendsOrImplementsKeyword != this.ExtendsOrImplementsKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.ExtendsOrImplementsTypeConstraint(this.Kind(), extendsOrImplementsKeyword, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExtendsOrImplementsTypeConstraintSyntax WithExtendsOrImplementsKeyword(SyntaxToken extendsOrImplementsKeyword)
    {
        return this.Update(extendsOrImplementsKeyword, this.Type);
    }

    internal override TypeConstraintSyntax WithTypeCore(TypeSyntax type) => WithType(type);
    public new ExtendsOrImplementsTypeConstraintSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.ExtendsOrImplementsKeyword, type);
    }
  }

  public abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseFieldDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeSyntax> AttributeLists { get; }
    public BaseFieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeListsCore(attributeLists);
    internal abstract BaseFieldDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists);

    public BaseFieldDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items) => AddAttributeListsCore(items);
    internal abstract BaseFieldDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items);

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }
    public BaseFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) => WithModifiersCore(modifiers);
    internal abstract BaseFieldDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers);

    public BaseFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items) => AddModifiersCore(items);
    internal abstract BaseFieldDeclarationSyntax AddModifiersCore(params SyntaxToken[] items);

    public abstract VariableDeclarationSyntax Declaration { get; }
    public BaseFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration) => WithDeclarationCore(declaration);
    internal abstract BaseFieldDeclarationSyntax WithDeclarationCore(VariableDeclarationSyntax declaration);

    public abstract SyntaxToken EosToken { get; }
    public BaseFieldDeclarationSyntax WithEosToken(SyntaxToken eosToken) => WithEosTokenCore(eosToken);
    internal abstract BaseFieldDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken);
  }

  public sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private VariableDeclarationSyntax declaration;

    internal FieldDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public override VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 2);
        }
    }

    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.FieldDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 2: return this.GetRed(ref this.declaration, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 2: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFieldDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFieldDeclaration(this);
    }

    public FieldDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseFieldDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new FieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Declaration, this.EosToken);
    }

    internal override BaseFieldDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new FieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Declaration, this.EosToken);
    }

    internal override BaseFieldDeclarationSyntax WithDeclarationCore(VariableDeclarationSyntax declaration) => WithDeclaration(declaration);
    public new FieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.AttributeLists, this.Modifiers, declaration, this.EosToken);
    }

    internal override BaseFieldDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new FieldDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Declaration, eosToken);
    }
    internal override BaseFieldDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new FieldDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseFieldDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new FieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
  }

  public sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private VariableDeclarationSyntax declaration;

    internal EventFieldDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken EventKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EventFieldDeclarationSyntax)this.Green).eventKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override VariableDeclarationSyntax Declaration 
    {
        get
        {
            return this.GetRed(ref this.declaration, 3);
        }
    }

    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EventFieldDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(4), this.GetChildIndex(4));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.declaration, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.declaration;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventFieldDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEventFieldDeclaration(this);
    }

    public EventFieldDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, eventKeyword, declaration, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseFieldDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new EventFieldDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.EventKeyword, this.Declaration, this.EosToken);
    }

    internal override BaseFieldDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new EventFieldDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.EventKeyword, this.Declaration, this.EosToken);
    }

    public EventFieldDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, eventKeyword, this.Declaration, this.EosToken);
    }

    internal override BaseFieldDeclarationSyntax WithDeclarationCore(VariableDeclarationSyntax declaration) => WithDeclaration(declaration);
    public new EventFieldDeclarationSyntax WithDeclaration(VariableDeclarationSyntax declaration)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, declaration, this.EosToken);
    }

    internal override BaseFieldDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new EventFieldDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Declaration, eosToken);
    }
    internal override BaseFieldDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new EventFieldDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseFieldDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new EventFieldDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
  }

  public sealed partial class ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode
  {
    private NameSyntax name;

    internal ExplicitInterfaceSpecifierSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public NameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public SyntaxToken DotToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)this.Green).dotToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)
    {
        if (name != this.Name || dotToken != this.DotToken)
        {
            var newNode = SyntaxFactory.ExplicitInterfaceSpecifier(name, dotToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ExplicitInterfaceSpecifierSyntax WithName(NameSyntax name)
    {
        return this.Update(name, this.DotToken);
    }

    public ExplicitInterfaceSpecifierSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Name, dotToken);
    }
  }

  /// <summary>Base type for method declaration syntax.</summary>
  public abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseMethodDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeSyntax> AttributeLists { get; }
    public BaseMethodDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeListsCore(attributeLists);
    internal abstract BaseMethodDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists);

    public BaseMethodDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items) => AddAttributeListsCore(items);
    internal abstract BaseMethodDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items);

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }
    public BaseMethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) => WithModifiersCore(modifiers);
    internal abstract BaseMethodDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers);

    public BaseMethodDeclarationSyntax AddModifiers(params SyntaxToken[] items) => AddModifiersCore(items);
    internal abstract BaseMethodDeclarationSyntax AddModifiersCore(params SyntaxToken[] items);

    /// <summary>Gets the parameter list.</summary>
    public abstract ParameterListSyntax ParameterList { get; }
    public BaseMethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList) => WithParameterListCore(parameterList);
    internal abstract BaseMethodDeclarationSyntax WithParameterListCore(ParameterListSyntax parameterList);

    public BaseMethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items) => AddParameterListParametersCore(items);
    internal abstract BaseMethodDeclarationSyntax AddParameterListParametersCore(params ParameterSyntax[] items);

    /// <summary>Gets the contract clause list.</summary>
    public abstract SyntaxList<ContractClauseSyntax> ContractClauses { get; }
    public BaseMethodDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClausesCore(contractClauses);
    internal abstract BaseMethodDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses);

    public BaseMethodDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items) => AddContractClausesCore(items);
    internal abstract BaseMethodDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items);

    public abstract BlockSyntax Body { get; }
    public BaseMethodDeclarationSyntax WithBody(BlockSyntax body) => WithBodyCore(body);
    internal abstract BaseMethodDeclarationSyntax WithBodyCore(BlockSyntax body);

    public BaseMethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items) => AddBodyStatementsCore(items);
    internal abstract BaseMethodDeclarationSyntax AddBodyStatementsCore(params StatementSyntax[] items);

    public abstract ArrowExpressionClauseSyntax ExpressionBody { get; }
    public BaseMethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody) => WithExpressionBodyCore(expressionBody);
    internal abstract BaseMethodDeclarationSyntax WithExpressionBodyCore(ArrowExpressionClauseSyntax expressionBody);

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken EosToken { get; }
    public BaseMethodDeclarationSyntax WithEosToken(SyntaxToken eosToken) => WithEosTokenCore(eosToken);
    internal abstract BaseMethodDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken);
  }

  /// <summary>Method declaration syntax.</summary>
  public sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private TypeParameterListSyntax typeParameterList;
    private ParameterListSyntax parameterList;
    private TypeSyntax returnType;
    private SyntaxNode constraintClauses;
    private SyntaxNode contractClauses;
    private ThrowsListSyntax throwsList;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal MethodDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the func keyword.</summary>
    public SyntaxToken FuncKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MethodDeclarationSyntax)this.Green).funcKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
        get
        {
            return this.GetRed(ref this.explicitInterfaceSpecifier, 3);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MethodDeclarationSyntax)this.Green).identifier, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public TypeParameterListSyntax TypeParameterList 
    {
        get
        {
            return this.GetRed(ref this.typeParameterList, 5);
        }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 6);
        }
    }

    /// <summary>Gets the arrow token.</summary>
    public SyntaxToken ReturnToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MethodDeclarationSyntax)this.Green).returnToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(7), this.GetChildIndex(7));

            return default(SyntaxToken);
        }
    }

    /// <summary>Gets the return type syntax.</summary>
    public TypeSyntax ReturnType 
    {
        get
        {
            return this.GetRed(ref this.returnType, 8);
        }
    }

    /// <summary>Gets the constraint clause list.</summary>
    public SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses 
    {
        get
        {
            return new SyntaxList<TypeParameterConstraintClauseSyntax>(this.GetRed(ref this.constraintClauses, 9));
        }
    }

    public override SyntaxList<ContractClauseSyntax> ContractClauses 
    {
        get
        {
            return new SyntaxList<ContractClauseSyntax>(this.GetRed(ref this.contractClauses, 10));
        }
    }

    /// <summary>Gets the throws list.</summary>
    public ThrowsListSyntax ThrowsList 
    {
        get
        {
            return this.GetRed(ref this.throwsList, 11);
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 12);
        }
    }

    public override ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 13);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.MethodDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(14), this.GetChildIndex(14));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.explicitInterfaceSpecifier, 3);
            case 5: return this.GetRed(ref this.typeParameterList, 5);
            case 6: return this.GetRed(ref this.parameterList, 6);
            case 8: return this.GetRed(ref this.returnType, 8);
            case 9: return this.GetRed(ref this.constraintClauses, 9);
            case 10: return this.GetRed(ref this.contractClauses, 10);
            case 11: return this.GetRed(ref this.throwsList, 11);
            case 12: return this.GetRed(ref this.body, 12);
            case 13: return this.GetRed(ref this.expressionBody, 13);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.explicitInterfaceSpecifier;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 8: return this.returnType;
            case 9: return this.constraintClauses;
            case 10: return this.contractClauses;
            case 11: return this.throwsList;
            case 12: return this.body;
            case 13: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMethodDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMethodDeclaration(this);
    }

    public MethodDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken funcKeyword, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxToken returnToken, TypeSyntax returnType, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<ContractClauseSyntax> contractClauses, ThrowsListSyntax throwsList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || funcKeyword != this.FuncKeyword || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || returnToken != this.ReturnToken || returnType != this.ReturnType || constraintClauses != this.ConstraintClauses || contractClauses != this.ContractClauses || throwsList != this.ThrowsList || body != this.Body || expressionBody != this.ExpressionBody || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.MethodDeclaration(attributeLists, modifiers, funcKeyword, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, returnToken, returnType, constraintClauses, contractClauses, throwsList, body, expressionBody, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseMethodDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new MethodDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new MethodDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    public MethodDeclarationSyntax WithFuncKeyword(SyntaxToken funcKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, funcKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    public MethodDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, explicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    public MethodDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    public MethodDeclarationSyntax WithTypeParameterList(TypeParameterListSyntax typeParameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, typeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithParameterListCore(ParameterListSyntax parameterList) => WithParameterList(parameterList);
    public new MethodDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, parameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    public MethodDeclarationSyntax WithReturnToken(SyntaxToken returnToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, returnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    public MethodDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, returnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    public MethodDeclarationSyntax WithConstraintClauses(SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, constraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClauses(contractClauses);
    public new MethodDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, contractClauses, this.ThrowsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    public MethodDeclarationSyntax WithThrowsList(ThrowsListSyntax throwsList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, throwsList, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithBodyCore(BlockSyntax body) => WithBody(body);
    public new MethodDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithExpressionBodyCore(ArrowExpressionClauseSyntax expressionBody) => WithExpressionBody(expressionBody);
    public new MethodDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, expressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new MethodDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.TypeParameterList, this.ParameterList, this.ReturnToken, this.ReturnType, this.ConstraintClauses, this.ContractClauses, this.ThrowsList, this.Body, this.ExpressionBody, eosToken);
    }
    internal override BaseMethodDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new MethodDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new MethodDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public MethodDeclarationSyntax AddTypeParameterListParameters(params TypeParameterSyntax[] items)
    {
        var typeParameterList = this.TypeParameterList ?? SyntaxFactory.TypeParameterList();
        return this.WithTypeParameterList(typeParameterList.WithParameters(typeParameterList.Parameters.AddRange(items)));
    }
    internal override BaseMethodDeclarationSyntax AddParameterListParametersCore(params ParameterSyntax[] items) => AddParameterListParameters(items);

    public new MethodDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }

    public MethodDeclarationSyntax AddConstraintClauses(params TypeParameterConstraintClauseSyntax[] items)
    {
        return this.WithConstraintClauses(this.ConstraintClauses.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items) => AddContractClauses(items);

    public new MethodDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items)
    {
        return this.WithContractClauses(this.ContractClauses.AddRange(items));
    }

    public MethodDeclarationSyntax AddThrowsListTypes(params TypeSyntax[] items)
    {
        var throwsList = this.ThrowsList ?? SyntaxFactory.ThrowsList();
        return this.WithThrowsList(throwsList.WithTypes(throwsList.Types.AddRange(items)));
    }
    internal override BaseMethodDeclarationSyntax AddBodyStatementsCore(params StatementSyntax[] items) => AddBodyStatements(items);

    public new MethodDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Operator declaration syntax.</summary>
  public sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeSyntax returnType;
    private ParameterListSyntax parameterList;
    private SyntaxNode contractClauses;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal OperatorDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType 
    {
        get
        {
            return this.GetRed(ref this.returnType, 2);
        }
    }

    /// <summary>Gets the "operator" keyword.</summary>
    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OperatorDeclarationSyntax)this.Green).operatorKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OperatorDeclarationSyntax)this.Green).operatorToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 5);
        }
    }

    public override SyntaxList<ContractClauseSyntax> ContractClauses 
    {
        get
        {
            return new SyntaxList<ContractClauseSyntax>(this.GetRed(ref this.contractClauses, 6));
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 7);
        }
    }

    public override ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 8);
        }
    }

    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OperatorDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(9), this.GetChildIndex(9));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 2: return this.GetRed(ref this.returnType, 2);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 6: return this.GetRed(ref this.contractClauses, 6);
            case 7: return this.GetRed(ref this.body, 7);
            case 8: return this.GetRed(ref this.expressionBody, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 2: return this.returnType;
            case 5: return this.parameterList;
            case 6: return this.contractClauses;
            case 7: return this.body;
            case 8: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOperatorDeclaration(this);
    }

    public OperatorDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, SyntaxList<ContractClauseSyntax> contractClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || contractClauses != this.ContractClauses || body != this.Body || expressionBody != this.ExpressionBody || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, contractClauses, body, expressionBody, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseMethodDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new OperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new OperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public OperatorDeclarationSyntax WithReturnType(TypeSyntax returnType)
    {
        return this.Update(this.AttributeLists, this.Modifiers, returnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public OperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, operatorKeyword, this.OperatorToken, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public OperatorDeclarationSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, operatorToken, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithParameterListCore(ParameterListSyntax parameterList) => WithParameterList(parameterList);
    public new OperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, parameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClauses(contractClauses);
    public new OperatorDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, contractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithBodyCore(BlockSyntax body) => WithBody(body);
    public new OperatorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.ContractClauses, body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithExpressionBodyCore(ArrowExpressionClauseSyntax expressionBody) => WithExpressionBody(expressionBody);
    public new OperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.ContractClauses, this.Body, expressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new OperatorDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ReturnType, this.OperatorKeyword, this.OperatorToken, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, eosToken);
    }
    internal override BaseMethodDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new OperatorDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new OperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddParameterListParametersCore(params ParameterSyntax[] items) => AddParameterListParameters(items);

    public new OperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }
    internal override BaseMethodDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items) => AddContractClauses(items);

    public new OperatorDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items)
    {
        return this.WithContractClauses(this.ContractClauses.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddBodyStatementsCore(params StatementSyntax[] items) => AddBodyStatements(items);

    public new OperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Conversion operator declaration syntax.</summary>
  public sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeSyntax type;
    private ParameterListSyntax parameterList;
    private SyntaxNode contractClauses;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal ConversionOperatorDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the "implicit" or "explicit" token.</summary>
    public SyntaxToken ImplicitOrExplicitKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax)this.Green).implicitOrExplicitKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the "operator" token.</summary>
    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax)this.Green).operatorKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    /// <summary>Gets the type.</summary>
    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 4);
        }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 5);
        }
    }

    public override SyntaxList<ContractClauseSyntax> ContractClauses 
    {
        get
        {
            return new SyntaxList<ContractClauseSyntax>(this.GetRed(ref this.contractClauses, 6));
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 7);
        }
    }

    public override ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 8);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(9), this.GetChildIndex(9));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.type, 4);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 6: return this.GetRed(ref this.contractClauses, 6);
            case 7: return this.GetRed(ref this.body, 7);
            case 8: return this.GetRed(ref this.expressionBody, 8);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.type;
            case 5: return this.parameterList;
            case 6: return this.contractClauses;
            case 7: return this.body;
            case 8: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorDeclaration(this);
    }

    public ConversionOperatorDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, SyntaxList<ContractClauseSyntax> contractClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || contractClauses != this.ContractClauses || body != this.Body || expressionBody != this.ExpressionBody || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, contractClauses, body, expressionBody, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseMethodDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new ConversionOperatorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new ConversionOperatorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public ConversionOperatorDeclarationSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, implicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public ConversionOperatorDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, operatorKeyword, this.Type, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public ConversionOperatorDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, type, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithParameterListCore(ParameterListSyntax parameterList) => WithParameterList(parameterList);
    public new ConversionOperatorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, parameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClauses(contractClauses);
    public new ConversionOperatorDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, contractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithBodyCore(BlockSyntax body) => WithBody(body);
    public new ConversionOperatorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.ContractClauses, body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithExpressionBodyCore(ArrowExpressionClauseSyntax expressionBody) => WithExpressionBody(expressionBody);
    public new ConversionOperatorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.ContractClauses, this.Body, expressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new ConversionOperatorDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, eosToken);
    }
    internal override BaseMethodDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new ConversionOperatorDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new ConversionOperatorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddParameterListParametersCore(params ParameterSyntax[] items) => AddParameterListParameters(items);

    public new ConversionOperatorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }
    internal override BaseMethodDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items) => AddContractClauses(items);

    public new ConversionOperatorDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items)
    {
        return this.WithContractClauses(this.ContractClauses.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddBodyStatementsCore(params StatementSyntax[] items) => AddBodyStatements(items);

    public new ConversionOperatorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Constructor declaration syntax.</summary>
  public sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private ParameterListSyntax parameterList;
    private ConstructorInitializerSyntax initializer;
    private SyntaxNode contractClauses;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal ConstructorDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the constructor keyword.</summary>
    public SyntaxToken ConstructorKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstructorDeclarationSyntax)this.Green).constructorKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 3);
        }
    }

    public ConstructorInitializerSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 4);
        }
    }

    public override SyntaxList<ContractClauseSyntax> ContractClauses 
    {
        get
        {
            return new SyntaxList<ContractClauseSyntax>(this.GetRed(ref this.contractClauses, 5));
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 6);
        }
    }

    public override ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 7);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstructorDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(8), this.GetChildIndex(8));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.parameterList, 3);
            case 4: return this.GetRed(ref this.initializer, 4);
            case 5: return this.GetRed(ref this.contractClauses, 5);
            case 6: return this.GetRed(ref this.body, 6);
            case 7: return this.GetRed(ref this.expressionBody, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.parameterList;
            case 4: return this.initializer;
            case 5: return this.contractClauses;
            case 6: return this.body;
            case 7: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorDeclaration(this);
    }

    public ConstructorDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken constructorKeyword, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, SyntaxList<ContractClauseSyntax> contractClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || constructorKeyword != this.ConstructorKeyword || parameterList != this.ParameterList || initializer != this.Initializer || contractClauses != this.ContractClauses || body != this.Body || expressionBody != this.ExpressionBody || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, constructorKeyword, parameterList, initializer, contractClauses, body, expressionBody, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseMethodDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new ConstructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.ConstructorKeyword, this.ParameterList, this.Initializer, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new ConstructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.ConstructorKeyword, this.ParameterList, this.Initializer, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public ConstructorDeclarationSyntax WithConstructorKeyword(SyntaxToken constructorKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, constructorKeyword, this.ParameterList, this.Initializer, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithParameterListCore(ParameterListSyntax parameterList) => WithParameterList(parameterList);
    public new ConstructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ConstructorKeyword, parameterList, this.Initializer, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public ConstructorDeclarationSyntax WithInitializer(ConstructorInitializerSyntax initializer)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ConstructorKeyword, this.ParameterList, initializer, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClauses(contractClauses);
    public new ConstructorDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ConstructorKeyword, this.ParameterList, this.Initializer, contractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithBodyCore(BlockSyntax body) => WithBody(body);
    public new ConstructorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ConstructorKeyword, this.ParameterList, this.Initializer, this.ContractClauses, body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithExpressionBodyCore(ArrowExpressionClauseSyntax expressionBody) => WithExpressionBody(expressionBody);
    public new ConstructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ConstructorKeyword, this.ParameterList, this.Initializer, this.ContractClauses, this.Body, expressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new ConstructorDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.ConstructorKeyword, this.ParameterList, this.Initializer, this.ContractClauses, this.Body, this.ExpressionBody, eosToken);
    }
    internal override BaseMethodDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new ConstructorDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new ConstructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddParameterListParametersCore(params ParameterSyntax[] items) => AddParameterListParameters(items);

    public new ConstructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }
    internal override BaseMethodDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items) => AddContractClauses(items);

    public new ConstructorDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items)
    {
        return this.WithContractClauses(this.ContractClauses.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddBodyStatementsCore(params StatementSyntax[] items) => AddBodyStatements(items);

    public new ConstructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Constructor initializer syntax.</summary>
  public sealed partial class ConstructorInitializerSyntax : CSharpSyntaxNode
  {
    private ArgumentListSyntax argumentList;

    internal ConstructorInitializerSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstructorInitializerSyntax)this.Green).colonToken, this.Position, 0); }
    }

    /// <summary>Gets the "this" or "base" keyword.</summary>
    public SyntaxToken ThisOrBaseKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConstructorInitializerSyntax)this.Green).thisOrBaseKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public ArgumentListSyntax ArgumentList 
    {
        get
        {
            return this.GetRed(ref this.argumentList, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.argumentList, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.argumentList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorInitializer(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorInitializer(this);
    }

    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
        if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ConstructorInitializer(this.Kind(), colonToken, thisOrBaseKeyword, argumentList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConstructorInitializerSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(colonToken, this.ThisOrBaseKeyword, this.ArgumentList);
    }

    public ConstructorInitializerSyntax WithThisOrBaseKeyword(SyntaxToken thisOrBaseKeyword)
    {
        return this.Update(this.ColonToken, thisOrBaseKeyword, this.ArgumentList);
    }

    public ConstructorInitializerSyntax WithArgumentList(ArgumentListSyntax argumentList)
    {
        return this.Update(this.ColonToken, this.ThisOrBaseKeyword, argumentList);
    }

    public ConstructorInitializerSyntax AddArgumentListArguments(params ArgumentSyntax[] items)
    {
        return this.WithArgumentList(this.ArgumentList.WithArguments(this.ArgumentList.Arguments.AddRange(items)));
    }
  }

  /// <summary>Destructor declaration syntax.</summary>
  public sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private ParameterListSyntax parameterList;
    private SyntaxNode contractClauses;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal DestructorDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the tilde token.</summary>
    public SyntaxToken TildeToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DestructorDeclarationSyntax)this.Green).tildeToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DestructorDeclarationSyntax)this.Green).identifier, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override ParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 4);
        }
    }

    public override SyntaxList<ContractClauseSyntax> ContractClauses 
    {
        get
        {
            return new SyntaxList<ContractClauseSyntax>(this.GetRed(ref this.contractClauses, 5));
        }
    }

    public override BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 6);
        }
    }

    public override ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 7);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DestructorDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(8), this.GetChildIndex(8));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.parameterList, 4);
            case 5: return this.GetRed(ref this.contractClauses, 5);
            case 6: return this.GetRed(ref this.body, 6);
            case 7: return this.GetRed(ref this.expressionBody, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.parameterList;
            case 5: return this.contractClauses;
            case 6: return this.body;
            case 7: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDestructorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDestructorDeclaration(this);
    }

    public DestructorDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, SyntaxList<ContractClauseSyntax> contractClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || contractClauses != this.ContractClauses || body != this.Body || expressionBody != this.ExpressionBody || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, tildeToken, identifier, parameterList, contractClauses, body, expressionBody, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BaseMethodDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new DestructorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new DestructorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public DestructorDeclarationSyntax WithTildeToken(SyntaxToken tildeToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, tildeToken, this.Identifier, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    public DestructorDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, identifier, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithParameterListCore(ParameterListSyntax parameterList) => WithParameterList(parameterList);
    public new DestructorDeclarationSyntax WithParameterList(ParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, this.Identifier, parameterList, this.ContractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClauses(contractClauses);
    public new DestructorDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, contractClauses, this.Body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithBodyCore(BlockSyntax body) => WithBody(body);
    public new DestructorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.ContractClauses, body, this.ExpressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithExpressionBodyCore(ArrowExpressionClauseSyntax expressionBody) => WithExpressionBody(expressionBody);
    public new DestructorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.ContractClauses, this.Body, expressionBody, this.EosToken);
    }

    internal override BaseMethodDeclarationSyntax WithEosTokenCore(SyntaxToken eosToken) => WithEosToken(eosToken);
    public new DestructorDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.TildeToken, this.Identifier, this.ParameterList, this.ContractClauses, this.Body, this.ExpressionBody, eosToken);
    }
    internal override BaseMethodDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new DestructorDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new DestructorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddParameterListParametersCore(params ParameterSyntax[] items) => AddParameterListParameters(items);

    public new DestructorDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }
    internal override BaseMethodDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items) => AddContractClauses(items);

    public new DestructorDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items)
    {
        return this.WithContractClauses(this.ContractClauses.AddRange(items));
    }
    internal override BaseMethodDeclarationSyntax AddBodyStatementsCore(params StatementSyntax[] items) => AddBodyStatements(items);

    public new DestructorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Base type for property declaration syntax.</summary>
  public abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BasePropertyDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract SyntaxList<AttributeSyntax> AttributeLists { get; }
    public BasePropertyDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeListsCore(attributeLists);
    internal abstract BasePropertyDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists);

    public BasePropertyDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items) => AddAttributeListsCore(items);
    internal abstract BasePropertyDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items);

    /// <summary>Gets the modifier list.</summary>
    public abstract SyntaxTokenList Modifiers { get; }
    public BasePropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers) => WithModifiersCore(modifiers);
    internal abstract BasePropertyDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers);

    public BasePropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items) => AddModifiersCore(items);
    internal abstract BasePropertyDeclarationSyntax AddModifiersCore(params SyntaxToken[] items);

    /// <summary>Gets the type syntax.</summary>
    public abstract TypeSyntax Type { get; }
    public BasePropertyDeclarationSyntax WithType(TypeSyntax type) => WithTypeCore(type);
    internal abstract BasePropertyDeclarationSyntax WithTypeCore(TypeSyntax type);

    /// <summary>Gets the optional explicit interface specifier.</summary>
    public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }
    public BasePropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier) => WithExplicitInterfaceSpecifierCore(explicitInterfaceSpecifier);
    internal abstract BasePropertyDeclarationSyntax WithExplicitInterfaceSpecifierCore(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier);

    /// <summary>Gets the contract clause list.</summary>
    public abstract SyntaxList<ContractClauseSyntax> ContractClauses { get; }
    public BasePropertyDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClausesCore(contractClauses);
    internal abstract BasePropertyDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses);

    public BasePropertyDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items) => AddContractClausesCore(items);
    internal abstract BasePropertyDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items);

    public abstract AccessorListSyntax AccessorList { get; }
    public BasePropertyDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList) => WithAccessorListCore(accessorList);
    internal abstract BasePropertyDeclarationSyntax WithAccessorListCore(AccessorListSyntax accessorList);

    public BasePropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items) => AddAccessorListAccessorsCore(items);
    internal abstract BasePropertyDeclarationSyntax AddAccessorListAccessorsCore(params AccessorDeclarationSyntax[] items);
  }

  public sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private TypeSyntax type;
    private SyntaxNode contractClauses;
    private AccessorListSyntax accessorList;
    private ArrowExpressionClauseSyntax expressionBody;
    private EqualsValueClauseSyntax initializer;

    internal PropertyDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the func keyword.</summary>
    public SyntaxToken FuncKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PropertyDeclarationSyntax)this.Green).funcKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
        get
        {
            return this.GetRed(ref this.explicitInterfaceSpecifier, 3);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PropertyDeclarationSyntax)this.Green).identifier, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    /// <summary>Gets the return type token.</summary>
    public SyntaxToken ReturnToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PropertyDeclarationSyntax)this.Green).returnToken, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 6);
        }
    }

    public override SyntaxList<ContractClauseSyntax> ContractClauses 
    {
        get
        {
            return new SyntaxList<ContractClauseSyntax>(this.GetRed(ref this.contractClauses, 7));
        }
    }

    public override AccessorListSyntax AccessorList 
    {
        get
        {
            return this.GetRed(ref this.accessorList, 8);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 9);
        }
    }

    public EqualsValueClauseSyntax Initializer 
    {
        get
        {
            return this.GetRed(ref this.initializer, 10);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PropertyDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(11), this.GetChildIndex(11));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.explicitInterfaceSpecifier, 3);
            case 6: return this.GetRed(ref this.type, 6);
            case 7: return this.GetRed(ref this.contractClauses, 7);
            case 8: return this.GetRed(ref this.accessorList, 8);
            case 9: return this.GetRed(ref this.expressionBody, 9);
            case 10: return this.GetRed(ref this.initializer, 10);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.explicitInterfaceSpecifier;
            case 6: return this.type;
            case 7: return this.contractClauses;
            case 8: return this.accessorList;
            case 9: return this.expressionBody;
            case 10: return this.initializer;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPropertyDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPropertyDeclaration(this);
    }

    public PropertyDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken funcKeyword, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, SyntaxToken returnToken, TypeSyntax type, SyntaxList<ContractClauseSyntax> contractClauses, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || funcKeyword != this.FuncKeyword || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || returnToken != this.ReturnToken || type != this.Type || contractClauses != this.ContractClauses || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || initializer != this.Initializer || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, funcKeyword, explicitInterfaceSpecifier, identifier, returnToken, type, contractClauses, accessorList, expressionBody, initializer, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BasePropertyDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new PropertyDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new PropertyDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    public PropertyDeclarationSyntax WithFuncKeyword(SyntaxToken funcKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, funcKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithExplicitInterfaceSpecifierCore(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier) => WithExplicitInterfaceSpecifier(explicitInterfaceSpecifier);
    public new PropertyDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, explicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    public PropertyDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, identifier, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    public PropertyDeclarationSyntax WithReturnToken(SyntaxToken returnToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, returnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithTypeCore(TypeSyntax type) => WithType(type);
    public new PropertyDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClauses(contractClauses);
    public new PropertyDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, contractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithAccessorListCore(AccessorListSyntax accessorList) => WithAccessorList(accessorList);
    public new PropertyDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, this.ContractClauses, accessorList, this.ExpressionBody, this.Initializer, this.EosToken);
    }

    public PropertyDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, expressionBody, this.Initializer, this.EosToken);
    }

    public PropertyDeclarationSyntax WithInitializer(EqualsValueClauseSyntax initializer)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, initializer, this.EosToken);
    }

    public PropertyDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.ExplicitInterfaceSpecifier, this.Identifier, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.Initializer, eosToken);
    }
    internal override BasePropertyDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new PropertyDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BasePropertyDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new PropertyDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override BasePropertyDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items) => AddContractClauses(items);

    public new PropertyDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items)
    {
        return this.WithContractClauses(this.ContractClauses.AddRange(items));
    }
    internal override BasePropertyDeclarationSyntax AddAccessorListAccessorsCore(params AccessorDeclarationSyntax[] items) => AddAccessorListAccessors(items);

    public new PropertyDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        var accessorList = this.AccessorList ?? SyntaxFactory.AccessorList();
        return this.WithAccessorList(accessorList.WithAccessors(accessorList.Accessors.AddRange(items)));
    }
  }

  /// <summary>The syntax for the expression body of an expression-bodied member.</summary>
  public sealed partial class ArrowExpressionClauseSyntax : CSharpSyntaxNode
  {
    private ExpressionSyntax expression;

    internal ArrowExpressionClauseSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ArrowToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)this.Green).arrowToken, this.Position, 0); }
    }

    public ExpressionSyntax Expression 
    {
        get
        {
            return this.GetRed(ref this.expression, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.expression, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.expression;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrowExpressionClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrowExpressionClause(this);
    }

    public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression)
    {
        if (arrowToken != this.ArrowToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.ArrowExpressionClause(arrowToken, expression);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ArrowExpressionClauseSyntax WithArrowToken(SyntaxToken arrowToken)
    {
        return this.Update(arrowToken, this.Expression);
    }

    public ArrowExpressionClauseSyntax WithExpression(ExpressionSyntax expression)
    {
        return this.Update(this.ArrowToken, expression);
    }
  }

  public sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeSyntax type;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private SyntaxNode contractClauses;
    private AccessorListSyntax accessorList;

    internal EventDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken EventKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EventDeclarationSyntax)this.Green).eventKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 3);
        }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
        get
        {
            return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EventDeclarationSyntax)this.Green).identifier, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override SyntaxList<ContractClauseSyntax> ContractClauses 
    {
        get
        {
            return new SyntaxList<ContractClauseSyntax>(this.GetRed(ref this.contractClauses, 6));
        }
    }

    public override AccessorListSyntax AccessorList 
    {
        get
        {
            return this.GetRed(ref this.accessorList, 7);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.type, 3);
            case 4: return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
            case 6: return this.GetRed(ref this.contractClauses, 6);
            case 7: return this.GetRed(ref this.accessorList, 7);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 6: return this.contractClauses;
            case 7: return this.accessorList;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEventDeclaration(this);
    }

    public EventDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, SyntaxList<ContractClauseSyntax> contractClauses, AccessorListSyntax accessorList)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || contractClauses != this.ContractClauses || accessorList != this.AccessorList)
        {
            var newNode = SyntaxFactory.EventDeclaration(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, contractClauses, accessorList);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BasePropertyDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new EventDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.ContractClauses, this.AccessorList);
    }

    internal override BasePropertyDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new EventDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.ContractClauses, this.AccessorList);
    }

    public EventDeclarationSyntax WithEventKeyword(SyntaxToken eventKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, eventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.ContractClauses, this.AccessorList);
    }

    internal override BasePropertyDeclarationSyntax WithTypeCore(TypeSyntax type) => WithType(type);
    public new EventDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, type, this.ExplicitInterfaceSpecifier, this.Identifier, this.ContractClauses, this.AccessorList);
    }

    internal override BasePropertyDeclarationSyntax WithExplicitInterfaceSpecifierCore(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier) => WithExplicitInterfaceSpecifier(explicitInterfaceSpecifier);
    public new EventDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Type, explicitInterfaceSpecifier, this.Identifier, this.ContractClauses, this.AccessorList);
    }

    public EventDeclarationSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, identifier, this.ContractClauses, this.AccessorList);
    }

    internal override BasePropertyDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClauses(contractClauses);
    public new EventDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, contractClauses, this.AccessorList);
    }

    internal override BasePropertyDeclarationSyntax WithAccessorListCore(AccessorListSyntax accessorList) => WithAccessorList(accessorList);
    public new EventDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.EventKeyword, this.Type, this.ExplicitInterfaceSpecifier, this.Identifier, this.ContractClauses, accessorList);
    }
    internal override BasePropertyDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new EventDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BasePropertyDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new EventDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
    internal override BasePropertyDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items) => AddContractClauses(items);

    public new EventDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items)
    {
        return this.WithContractClauses(this.ContractClauses.AddRange(items));
    }
    internal override BasePropertyDeclarationSyntax AddAccessorListAccessorsCore(params AccessorDeclarationSyntax[] items) => AddAccessorListAccessors(items);

    public new EventDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        return this.WithAccessorList(this.AccessorList.WithAccessors(this.AccessorList.Accessors.AddRange(items)));
    }
  }

  public sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    private BracketedParameterListSyntax parameterList;
    private TypeSyntax type;
    private SyntaxNode contractClauses;
    private AccessorListSyntax accessorList;
    private ArrowExpressionClauseSyntax expressionBody;

    internal IndexerDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    public override SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the func keyword.</summary>
    public SyntaxToken FuncKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IndexerDeclarationSyntax)this.Green).funcKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the operator keyword.</summary>
    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IndexerDeclarationSyntax)this.Green).operatorKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier 
    {
        get
        {
            return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
        }
    }

    /// <summary>Gets the parameter list.</summary>
    public BracketedParameterListSyntax ParameterList 
    {
        get
        {
            return this.GetRed(ref this.parameterList, 5);
        }
    }

    /// <summary>Gets the arrow token.</summary>
    public SyntaxToken ReturnToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IndexerDeclarationSyntax)this.Green).returnToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(6), this.GetChildIndex(6));

            return default(SyntaxToken);
        }
    }

    public override TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 7);
        }
    }

    public override SyntaxList<ContractClauseSyntax> ContractClauses 
    {
        get
        {
            return new SyntaxList<ContractClauseSyntax>(this.GetRed(ref this.contractClauses, 8));
        }
    }

    public override AccessorListSyntax AccessorList 
    {
        get
        {
            return this.GetRed(ref this.accessorList, 9);
        }
    }

    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 10);
        }
    }

    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IndexerDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(11), this.GetChildIndex(11));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 4: return this.GetRed(ref this.explicitInterfaceSpecifier, 4);
            case 5: return this.GetRed(ref this.parameterList, 5);
            case 7: return this.GetRed(ref this.type, 7);
            case 8: return this.GetRed(ref this.contractClauses, 8);
            case 9: return this.GetRed(ref this.accessorList, 9);
            case 10: return this.GetRed(ref this.expressionBody, 10);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 4: return this.explicitInterfaceSpecifier;
            case 5: return this.parameterList;
            case 7: return this.type;
            case 8: return this.contractClauses;
            case 9: return this.accessorList;
            case 10: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIndexerDeclaration(this);
    }

    public IndexerDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken funcKeyword, SyntaxToken operatorKeyword, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, SyntaxToken returnToken, TypeSyntax type, SyntaxList<ContractClauseSyntax> contractClauses, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || funcKeyword != this.FuncKeyword || operatorKeyword != this.OperatorKeyword || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || parameterList != this.ParameterList || returnToken != this.ReturnToken || type != this.Type || contractClauses != this.ContractClauses || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, funcKeyword, operatorKeyword, explicitInterfaceSpecifier, parameterList, returnToken, type, contractClauses, accessorList, expressionBody, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override BasePropertyDeclarationSyntax WithAttributeListsCore(SyntaxList<AttributeSyntax> attributeLists) => WithAttributeLists(attributeLists);
    public new IndexerDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithModifiersCore(SyntaxTokenList modifiers) => WithModifiers(modifiers);
    public new IndexerDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    public IndexerDeclarationSyntax WithFuncKeyword(SyntaxToken funcKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, funcKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    public IndexerDeclarationSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, operatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithExplicitInterfaceSpecifierCore(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier) => WithExplicitInterfaceSpecifier(explicitInterfaceSpecifier);
    public new IndexerDeclarationSyntax WithExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, explicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    public IndexerDeclarationSyntax WithParameterList(BracketedParameterListSyntax parameterList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, parameterList, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    public IndexerDeclarationSyntax WithReturnToken(SyntaxToken returnToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, returnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithTypeCore(TypeSyntax type) => WithType(type);
    public new IndexerDeclarationSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, type, this.ContractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithContractClausesCore(SyntaxList<ContractClauseSyntax> contractClauses) => WithContractClauses(contractClauses);
    public new IndexerDeclarationSyntax WithContractClauses(SyntaxList<ContractClauseSyntax> contractClauses)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, contractClauses, this.AccessorList, this.ExpressionBody, this.EosToken);
    }

    internal override BasePropertyDeclarationSyntax WithAccessorListCore(AccessorListSyntax accessorList) => WithAccessorList(accessorList);
    public new IndexerDeclarationSyntax WithAccessorList(AccessorListSyntax accessorList)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, this.ContractClauses, accessorList, this.ExpressionBody, this.EosToken);
    }

    public IndexerDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, expressionBody, this.EosToken);
    }

    public IndexerDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.FuncKeyword, this.OperatorKeyword, this.ExplicitInterfaceSpecifier, this.ParameterList, this.ReturnToken, this.Type, this.ContractClauses, this.AccessorList, this.ExpressionBody, eosToken);
    }
    internal override BasePropertyDeclarationSyntax AddAttributeListsCore(params AttributeSyntax[] items) => AddAttributeLists(items);

    public new IndexerDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
    internal override BasePropertyDeclarationSyntax AddModifiersCore(params SyntaxToken[] items) => AddModifiers(items);

    public new IndexerDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public IndexerDeclarationSyntax AddParameterListParameters(params ParameterSyntax[] items)
    {
        return this.WithParameterList(this.ParameterList.WithParameters(this.ParameterList.Parameters.AddRange(items)));
    }
    internal override BasePropertyDeclarationSyntax AddContractClausesCore(params ContractClauseSyntax[] items) => AddContractClauses(items);

    public new IndexerDeclarationSyntax AddContractClauses(params ContractClauseSyntax[] items)
    {
        return this.WithContractClauses(this.ContractClauses.AddRange(items));
    }
    internal override BasePropertyDeclarationSyntax AddAccessorListAccessorsCore(params AccessorDeclarationSyntax[] items) => AddAccessorListAccessors(items);

    public new IndexerDeclarationSyntax AddAccessorListAccessors(params AccessorDeclarationSyntax[] items)
    {
        var accessorList = this.AccessorList ?? SyntaxFactory.AccessorList();
        return this.WithAccessorList(accessorList.WithAccessors(accessorList.Accessors.AddRange(items)));
    }
  }

  public sealed partial class AccessorListSyntax : CSharpSyntaxNode
  {
    private SyntaxNode accessors;

    internal AccessorListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OpenBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AccessorListSyntax)this.Green).openBraceToken, this.Position, 0); }
    }

    public SyntaxList<AccessorDeclarationSyntax> Accessors 
    {
        get
        {
            return new SyntaxList<AccessorDeclarationSyntax>(this.GetRed(ref this.accessors, 1));
        }
    }

    public SyntaxToken CloseBraceToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AccessorListSyntax)this.Green).closeBraceToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.accessors, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.accessors;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAccessorList(this);
    }

    public AccessorListSyntax Update(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AccessorList(openBraceToken, accessors, closeBraceToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AccessorListSyntax WithOpenBraceToken(SyntaxToken openBraceToken)
    {
        return this.Update(openBraceToken, this.Accessors, this.CloseBraceToken);
    }

    public AccessorListSyntax WithAccessors(SyntaxList<AccessorDeclarationSyntax> accessors)
    {
        return this.Update(this.OpenBraceToken, accessors, this.CloseBraceToken);
    }

    public AccessorListSyntax WithCloseBraceToken(SyntaxToken closeBraceToken)
    {
        return this.Update(this.OpenBraceToken, this.Accessors, closeBraceToken);
    }

    public AccessorListSyntax AddAccessors(params AccessorDeclarationSyntax[] items)
    {
        return this.WithAccessors(this.Accessors.AddRange(items));
    }
  }

  public sealed partial class AccessorDeclarationSyntax : CSharpSyntaxNode
  {
    private SyntaxNode attributeLists;
    private BlockSyntax body;
    private ArrowExpressionClauseSyntax expressionBody;

    internal AccessorDeclarationSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    /// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
    public SyntaxToken Keyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AccessorDeclarationSyntax)this.Green).keyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    /// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
    public BlockSyntax Body 
    {
        get
        {
            return this.GetRed(ref this.body, 3);
        }
    }

    /// <summary>Gets the optional expression body.</summary>
    public ArrowExpressionClauseSyntax ExpressionBody 
    {
        get
        {
            return this.GetRed(ref this.expressionBody, 4);
        }
    }

    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken EosToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.AccessorDeclarationSyntax)this.Green).eosToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(5), this.GetChildIndex(5));

            return default(SyntaxToken);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.body, 3);
            case 4: return this.GetRed(ref this.expressionBody, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.body;
            case 4: return this.expressionBody;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAccessorDeclaration(this);
    }

    public AccessorDeclarationSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken eosToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || expressionBody != this.ExpressionBody || eosToken != this.EosToken)
        {
            var newNode = SyntaxFactory.AccessorDeclaration(this.Kind(), attributeLists, modifiers, keyword, body, expressionBody, eosToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public AccessorDeclarationSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Keyword, this.Body, this.ExpressionBody, this.EosToken);
    }

    public AccessorDeclarationSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Keyword, this.Body, this.ExpressionBody, this.EosToken);
    }

    public AccessorDeclarationSyntax WithKeyword(SyntaxToken keyword)
    {
        return this.Update(this.AttributeLists, this.Modifiers, keyword, this.Body, this.ExpressionBody, this.EosToken);
    }

    public AccessorDeclarationSyntax WithBody(BlockSyntax body)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, body, this.ExpressionBody, this.EosToken);
    }

    public AccessorDeclarationSyntax WithExpressionBody(ArrowExpressionClauseSyntax expressionBody)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Body, expressionBody, this.EosToken);
    }

    public AccessorDeclarationSyntax WithEosToken(SyntaxToken eosToken)
    {
        return this.Update(this.AttributeLists, this.Modifiers, this.Keyword, this.Body, this.ExpressionBody, eosToken);
    }

    public AccessorDeclarationSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public AccessorDeclarationSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }

    public AccessorDeclarationSyntax AddBodyStatements(params StatementSyntax[] items)
    {
        var body = this.Body ?? SyntaxFactory.Block();
        return this.WithBody(body.WithStatements(body.Statements.AddRange(items)));
    }
  }

  /// <summary>Base type for parameter list syntax.</summary>
  public abstract partial class BaseParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseParameterListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
    public BaseParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters) => WithParametersCore(parameters);
    internal abstract BaseParameterListSyntax WithParametersCore(SeparatedSyntaxList<ParameterSyntax> parameters);

    public BaseParameterListSyntax AddParameters(params ParameterSyntax[] items) => AddParametersCore(items);
    internal abstract BaseParameterListSyntax AddParametersCore(params ParameterSyntax[] items);
  }

  /// <summary>Parameter list syntax.</summary>
  public sealed partial class ParameterListSyntax : BaseParameterListSyntax
  {
    private SyntaxNode parameters;

    internal ParameterListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParameterListSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public override SeparatedSyntaxList<ParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<ParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ParameterSyntax>);
        }
    }

    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParameterListSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParameterList(this);
    }

    public ParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Parameters, this.CloseParenToken);
    }

    internal override BaseParameterListSyntax WithParametersCore(SeparatedSyntaxList<ParameterSyntax> parameters) => WithParameters(parameters);
    public new ParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters)
    {
        return this.Update(this.OpenParenToken, parameters, this.CloseParenToken);
    }

    public ParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Parameters, closeParenToken);
    }
    internal override BaseParameterListSyntax AddParametersCore(params ParameterSyntax[] items) => AddParameters(items);

    public new ParameterListSyntax AddParameters(params ParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>Parameter list syntax with surrounding brackets.</summary>
  public sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
  {
    private SyntaxNode parameters;

    internal BracketedParameterListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BracketedParameterListSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    public override SeparatedSyntaxList<ParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<ParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<ParameterSyntax>);
        }
    }

    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BracketedParameterListSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBracketedParameterList(this);
    }

    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public BracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Parameters, this.CloseBracketToken);
    }

    internal override BaseParameterListSyntax WithParametersCore(SeparatedSyntaxList<ParameterSyntax> parameters) => WithParameters(parameters);
    public new BracketedParameterListSyntax WithParameters(SeparatedSyntaxList<ParameterSyntax> parameters)
    {
        return this.Update(this.OpenBracketToken, parameters, this.CloseBracketToken);
    }

    public BracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Parameters, closeBracketToken);
    }
    internal override BaseParameterListSyntax AddParametersCore(params ParameterSyntax[] items) => AddParameters(items);

    public new BracketedParameterListSyntax AddParameters(params ParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>Parameter syntax.</summary>
  public sealed partial class ParameterSyntax : CSharpSyntaxNode
  {
    private SyntaxNode attributeLists;
    private TypeSyntax type;
    private EqualsValueClauseSyntax @default;

    internal ParameterSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParameterSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ParameterSyntax)this.Green).colonToken;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxToken);
        }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 3);
        }
    }

    public EqualsValueClauseSyntax Default 
    {
        get
        {
            return this.GetRed(ref this.@default, 4);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 3: return this.GetRed(ref this.type, 3);
            case 4: return this.GetRed(ref this.@default, 4);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 3: return this.type;
            case 4: return this.@default;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParameter(this);
    }

    public ParameterSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxToken identifier, SyntaxToken colonToken, TypeSyntax type, EqualsValueClauseSyntax @default)
    {
        if (attributeLists != this.AttributeLists || identifier != this.Identifier || colonToken != this.ColonToken || type != this.Type || @default != this.Default)
        {
            var newNode = SyntaxFactory.Parameter(attributeLists, identifier, colonToken, type, @default);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ParameterSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Identifier, this.ColonToken, this.Type, this.Default);
    }

    public ParameterSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.AttributeLists, identifier, this.ColonToken, this.Type, this.Default);
    }

    public ParameterSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.AttributeLists, this.Identifier, colonToken, this.Type, this.Default);
    }

    public ParameterSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Identifier, this.ColonToken, type, this.Default);
    }

    public ParameterSyntax WithDefault(EqualsValueClauseSyntax @default)
    {
        return this.Update(this.AttributeLists, this.Identifier, this.ColonToken, this.Type, @default);
    }

    public ParameterSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }
  }

  public sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
  {
    private SyntaxNode attributeLists;
    private TypeSyntax type;

    internal IncompleteMemberSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public SyntaxList<AttributeSyntax> AttributeLists 
    {
        get
        {
            return new SyntaxList<AttributeSyntax>(this.GetRed(ref this.attributeLists, 0));
        }
    }

    /// <summary>Gets the modifier list.</summary>
    public SyntaxTokenList Modifiers 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.attributeLists);
            case 2: return this.GetRed(ref this.type, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 2: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIncompleteMember(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIncompleteMember(this);
    }

    public IncompleteMemberSyntax Update(SyntaxList<AttributeSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
        {
            var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IncompleteMemberSyntax WithAttributeLists(SyntaxList<AttributeSyntax> attributeLists)
    {
        return this.Update(attributeLists, this.Modifiers, this.Type);
    }

    public IncompleteMemberSyntax WithModifiers(SyntaxTokenList modifiers)
    {
        return this.Update(this.AttributeLists, modifiers, this.Type);
    }

    public IncompleteMemberSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.AttributeLists, this.Modifiers, type);
    }

    public IncompleteMemberSyntax AddAttributeLists(params AttributeSyntax[] items)
    {
        return this.WithAttributeLists(this.AttributeLists.AddRange(items));
    }

    public IncompleteMemberSyntax AddModifiers(params SyntaxToken[] items)
    {
        return this.WithModifiers(this.Modifiers.AddRange(items));
    }
  }

  public sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
  {
    internal SkippedTokensTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxTokenList Tokens 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSkippedTokensTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSkippedTokensTrivia(this);
    }

    public SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
    {
        if (tokens != this.Tokens)
        {
            var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens)
    {
        return this.Update(tokens);
    }

    public SkippedTokensTriviaSyntax AddTokens(params SyntaxToken[] items)
    {
        return this.WithTokens(this.Tokens.AddRange(items));
    }
  }

  public sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
  {
    private SyntaxNode content;

    internal DocumentationCommentTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxList<XmlNodeSyntax> Content 
    {
        get
        {
            return new SyntaxList<XmlNodeSyntax>(this.GetRed(ref this.content, 0));
        }
    }

    public SyntaxToken EndOfComment 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DocumentationCommentTriviaSyntax)this.Green).endOfComment, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.content);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.content;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDocumentationCommentTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDocumentationCommentTrivia(this);
    }

    public DocumentationCommentTriviaSyntax Update(SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
        if (content != this.Content || endOfComment != this.EndOfComment)
        {
            var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind(), content, endOfComment);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public DocumentationCommentTriviaSyntax WithContent(SyntaxList<XmlNodeSyntax> content)
    {
        return this.Update(content, this.EndOfComment);
    }

    public DocumentationCommentTriviaSyntax WithEndOfComment(SyntaxToken endOfComment)
    {
        return this.Update(this.Content, endOfComment);
    }

    public DocumentationCommentTriviaSyntax AddContent(params XmlNodeSyntax[] items)
    {
        return this.WithContent(this.Content.AddRange(items));
    }
  }

  /// <summary>
  /// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
  /// For example, the M in &lt;see cref="M" /&gt;.
  /// </summary>
  public abstract partial class CrefSyntax : CSharpSyntaxNode
  {
    internal CrefSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>
  /// A symbol reference that definitely refers to a type.
  /// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  public sealed partial class TypeCrefSyntax : CrefSyntax
  {
    private TypeSyntax type;

    internal TypeCrefSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRedAtZero(ref this.type);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.type);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeCref(this);
    }

    public TypeCrefSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeCref(type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public TypeCrefSyntax WithType(TypeSyntax type)
    {
        return this.Update(type);
    }
  }

  /// <summary>
  /// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
  /// For example, cref="System.String.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  public sealed partial class QualifiedCrefSyntax : CrefSyntax
  {
    private TypeSyntax container;
    private MemberCrefSyntax member;

    internal QualifiedCrefSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Container 
    {
        get
        {
            return this.GetRedAtZero(ref this.container);
        }
    }

    public SyntaxToken DotToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.QualifiedCrefSyntax)this.Green).dotToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public MemberCrefSyntax Member 
    {
        get
        {
            return this.GetRed(ref this.member, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.container);
            case 2: return this.GetRed(ref this.member, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.container;
            case 2: return this.member;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedCref(this);
    }

    public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
        if (container != this.Container || dotToken != this.DotToken || member != this.Member)
        {
            var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public QualifiedCrefSyntax WithContainer(TypeSyntax container)
    {
        return this.Update(container, this.DotToken, this.Member);
    }

    public QualifiedCrefSyntax WithDotToken(SyntaxToken dotToken)
    {
        return this.Update(this.Container, dotToken, this.Member);
    }

    public QualifiedCrefSyntax WithMember(MemberCrefSyntax member)
    {
        return this.Update(this.Container, this.DotToken, member);
    }
  }

  /// <summary>
  /// The unqualified part of a CrefSyntax.
  /// For example, "ToString()" in "object.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  public abstract partial class MemberCrefSyntax : CrefSyntax
  {
    internal MemberCrefSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
  /// with an optional type parameter list) and an optional parameter list.
  /// For example, "M", "M&lt;T&gt;" or "M(int)".
  /// Also, "A::B()" or "string()".
  /// </summary>
  public sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
  {
    private TypeSyntax name;
    private CrefParameterListSyntax parameters;

    internal NameMemberCrefSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public TypeSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public CrefParameterListSyntax Parameters 
    {
        get
        {
            return this.GetRed(ref this.parameters, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameMemberCref(this);
    }

    public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters)
    {
        if (name != this.Name || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.NameMemberCref(name, parameters);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public NameMemberCrefSyntax WithName(TypeSyntax name)
    {
        return this.Update(name, this.Parameters);
    }

    public NameMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)
    {
        return this.Update(this.Name, parameters);
    }

    public NameMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
    {
        var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
        return this.WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
  /// For example, "this" or "this[int]".
  /// </summary>
  public sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
  {
    private CrefBracketedParameterListSyntax parameters;

    internal IndexerMemberCrefSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ThisKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IndexerMemberCrefSyntax)this.Green).thisKeyword, this.Position, 0); }
    }

    public CrefBracketedParameterListSyntax Parameters 
    {
        get
        {
            return this.GetRed(ref this.parameters, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIndexerMemberCref(this);
    }

    public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
        if (thisKeyword != this.ThisKeyword || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public IndexerMemberCrefSyntax WithThisKeyword(SyntaxToken thisKeyword)
    {
        return this.Update(thisKeyword, this.Parameters);
    }

    public IndexerMemberCrefSyntax WithParameters(CrefBracketedParameterListSyntax parameters)
    {
        return this.Update(this.ThisKeyword, parameters);
    }

    public IndexerMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
    {
        var parameters = this.Parameters ?? SyntaxFactory.CrefBracketedParameterList();
        return this.WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
  /// For example, "operator +" or "operator -[int]".
  /// NOTE: the operator must be overloadable.
  /// </summary>
  public sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
  {
    private CrefParameterListSyntax parameters;

    internal OperatorMemberCrefSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OperatorMemberCrefSyntax)this.Green).operatorKeyword, this.Position, 0); }
    }

    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.OperatorMemberCrefSyntax)this.Green).operatorToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public CrefParameterListSyntax Parameters 
    {
        get
        {
            return this.GetRed(ref this.parameters, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.parameters, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOperatorMemberCref(this);
    }

    public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
        if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public OperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(operatorKeyword, this.OperatorToken, this.Parameters);
    }

    public OperatorMemberCrefSyntax WithOperatorToken(SyntaxToken operatorToken)
    {
        return this.Update(this.OperatorKeyword, operatorToken, this.Parameters);
    }

    public OperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)
    {
        return this.Update(this.OperatorKeyword, this.OperatorToken, parameters);
    }

    public OperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
    {
        var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
        return this.WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
  /// For example, "implicit operator int" or "explicit operator MyType(int)".
  /// </summary>
  public sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
  {
    private TypeSyntax type;
    private CrefParameterListSyntax parameters;

    internal ConversionOperatorMemberCrefSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken ImplicitOrExplicitKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax)this.Green).implicitOrExplicitKeyword, this.Position, 0); }
    }

    public SyntaxToken OperatorKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax)this.Green).operatorKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 2);
        }
    }

    public CrefParameterListSyntax Parameters 
    {
        get
        {
            return this.GetRed(ref this.parameters, 3);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.type, 2);
            case 3: return this.GetRed(ref this.parameters, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.type;
            case 3: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorMemberCref(this);
    }

    public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
        if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public ConversionOperatorMemberCrefSyntax WithImplicitOrExplicitKeyword(SyntaxToken implicitOrExplicitKeyword)
    {
        return this.Update(implicitOrExplicitKeyword, this.OperatorKeyword, this.Type, this.Parameters);
    }

    public ConversionOperatorMemberCrefSyntax WithOperatorKeyword(SyntaxToken operatorKeyword)
    {
        return this.Update(this.ImplicitOrExplicitKeyword, operatorKeyword, this.Type, this.Parameters);
    }

    public ConversionOperatorMemberCrefSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.ImplicitOrExplicitKeyword, this.OperatorKeyword, type, this.Parameters);
    }

    public ConversionOperatorMemberCrefSyntax WithParameters(CrefParameterListSyntax parameters)
    {
        return this.Update(this.ImplicitOrExplicitKeyword, this.OperatorKeyword, this.Type, parameters);
    }

    public ConversionOperatorMemberCrefSyntax AddParametersParameters(params CrefParameterSyntax[] items)
    {
        var parameters = this.Parameters ?? SyntaxFactory.CrefParameterList();
        return this.WithParameters(parameters.WithParameters(parameters.Parameters.AddRange(items)));
    }
  }

  /// <summary>
  /// A list of cref parameters with surrounding punctuation.
  /// Unlike regular parameters, cref parameters do not have names.
  /// </summary>
  public abstract partial class BaseCrefParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseCrefParameterListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
    public BaseCrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters) => WithParametersCore(parameters);
    internal abstract BaseCrefParameterListSyntax WithParametersCore(SeparatedSyntaxList<CrefParameterSyntax> parameters);

    public BaseCrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items) => AddParametersCore(items);
    internal abstract BaseCrefParameterListSyntax AddParametersCore(params CrefParameterSyntax[] items);
  }

  /// <summary>
  /// A parenthesized list of cref parameters.
  /// </summary>
  public sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
  {
    private SyntaxNode parameters;

    internal CrefParameterListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CrefParameterListSyntax)this.Green).openParenToken, this.Position, 0); }
    }

    public override SeparatedSyntaxList<CrefParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<CrefParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<CrefParameterSyntax>);
        }
    }

    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CrefParameterListSyntax)this.Green).closeParenToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefParameterList(this);
    }

    public CrefParameterListSyntax Update(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CrefParameterListSyntax WithOpenParenToken(SyntaxToken openParenToken)
    {
        return this.Update(openParenToken, this.Parameters, this.CloseParenToken);
    }

    internal override BaseCrefParameterListSyntax WithParametersCore(SeparatedSyntaxList<CrefParameterSyntax> parameters) => WithParameters(parameters);
    public new CrefParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters)
    {
        return this.Update(this.OpenParenToken, parameters, this.CloseParenToken);
    }

    public CrefParameterListSyntax WithCloseParenToken(SyntaxToken closeParenToken)
    {
        return this.Update(this.OpenParenToken, this.Parameters, closeParenToken);
    }
    internal override BaseCrefParameterListSyntax AddParametersCore(params CrefParameterSyntax[] items) => AddParameters(items);

    public new CrefParameterListSyntax AddParameters(params CrefParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>
  /// A bracketed list of cref parameters.
  /// </summary>
  public sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
  {
    private SyntaxNode parameters;

    internal CrefBracketedParameterListSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CrefBracketedParameterListSyntax)this.Green).openBracketToken, this.Position, 0); }
    }

    public override SeparatedSyntaxList<CrefParameterSyntax> Parameters 
    {
        get
        {
            var red = this.GetRed(ref this.parameters, 1);
            if (red != null)
                return new SeparatedSyntaxList<CrefParameterSyntax>(red, this.GetChildIndex(1));

            return default(SeparatedSyntaxList<CrefParameterSyntax>);
        }
    }

    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CrefBracketedParameterListSyntax)this.Green).closeBracketToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.parameters, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.parameters;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefBracketedParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefBracketedParameterList(this);
    }

    public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CrefBracketedParameterListSyntax WithOpenBracketToken(SyntaxToken openBracketToken)
    {
        return this.Update(openBracketToken, this.Parameters, this.CloseBracketToken);
    }

    internal override BaseCrefParameterListSyntax WithParametersCore(SeparatedSyntaxList<CrefParameterSyntax> parameters) => WithParameters(parameters);
    public new CrefBracketedParameterListSyntax WithParameters(SeparatedSyntaxList<CrefParameterSyntax> parameters)
    {
        return this.Update(this.OpenBracketToken, parameters, this.CloseBracketToken);
    }

    public CrefBracketedParameterListSyntax WithCloseBracketToken(SyntaxToken closeBracketToken)
    {
        return this.Update(this.OpenBracketToken, this.Parameters, closeBracketToken);
    }
    internal override BaseCrefParameterListSyntax AddParametersCore(params CrefParameterSyntax[] items) => AddParameters(items);

    public new CrefBracketedParameterListSyntax AddParameters(params CrefParameterSyntax[] items)
    {
        return this.WithParameters(this.Parameters.AddRange(items));
    }
  }

  /// <summary>
  /// An element of a BaseCrefParameterListSyntax.
  /// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
  /// there is no name and there are no attributes or other modifiers.
  /// </summary>
  public sealed partial class CrefParameterSyntax : CSharpSyntaxNode
  {
    private TypeSyntax type;

    internal CrefParameterSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken RefKindKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CrefParameterSyntax)this.Green).refKindKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.Position, 0);

            return default(SyntaxToken);
        }
    }

    public TypeSyntax Type 
    {
        get
        {
            return this.GetRed(ref this.type, 1);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.type, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.type;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefParameter(this);
    }

    public CrefParameterSyntax Update(SyntaxToken refKindKeyword, TypeSyntax type)
    {
        if (refKindKeyword != this.RefKindKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.CrefParameter(refKindKeyword, type);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public CrefParameterSyntax WithRefKindKeyword(SyntaxToken refKindKeyword)
    {
        return this.Update(refKindKeyword, this.Type);
    }

    public CrefParameterSyntax WithType(TypeSyntax type)
    {
        return this.Update(this.RefKindKeyword, type);
    }
  }

  public abstract partial class XmlNodeSyntax : CSharpSyntaxNode
  {
    internal XmlNodeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }
  }

  public sealed partial class XmlElementSyntax : XmlNodeSyntax
  {
    private XmlElementStartTagSyntax startTag;
    private SyntaxNode content;
    private XmlElementEndTagSyntax endTag;

    internal XmlElementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public XmlElementStartTagSyntax StartTag 
    {
        get
        {
            return this.GetRedAtZero(ref this.startTag);
        }
    }

    public SyntaxList<XmlNodeSyntax> Content 
    {
        get
        {
            return new SyntaxList<XmlNodeSyntax>(this.GetRed(ref this.content, 1));
        }
    }

    public XmlElementEndTagSyntax EndTag 
    {
        get
        {
            return this.GetRed(ref this.endTag, 2);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.startTag);
            case 1: return this.GetRed(ref this.content, 1);
            case 2: return this.GetRed(ref this.endTag, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startTag;
            case 1: return this.content;
            case 2: return this.endTag;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElement(this);
    }

    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
        if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
        {
            var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementSyntax WithStartTag(XmlElementStartTagSyntax startTag)
    {
        return this.Update(startTag, this.Content, this.EndTag);
    }

    public XmlElementSyntax WithContent(SyntaxList<XmlNodeSyntax> content)
    {
        return this.Update(this.StartTag, content, this.EndTag);
    }

    public XmlElementSyntax WithEndTag(XmlElementEndTagSyntax endTag)
    {
        return this.Update(this.StartTag, this.Content, endTag);
    }

    public XmlElementSyntax AddStartTagAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithStartTag(this.StartTag.WithAttributes(this.StartTag.Attributes.AddRange(items)));
    }

    public XmlElementSyntax AddContent(params XmlNodeSyntax[] items)
    {
        return this.WithContent(this.Content.AddRange(items));
    }
  }

  public sealed partial class XmlElementStartTagSyntax : CSharpSyntaxNode
  {
    private XmlNameSyntax name;
    private SyntaxNode attributes;

    internal XmlElementStartTagSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlElementStartTagSyntax)this.Green).lessThanToken, this.Position, 0); }
    }

    public XmlNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxList<XmlAttributeSyntax> Attributes 
    {
        get
        {
            return new SyntaxList<XmlAttributeSyntax>(this.GetRed(ref this.attributes, 2));
        }
    }

    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlElementStartTagSyntax)this.Green).greaterThanToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 2: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementStartTag(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementStartTag(this);
    }

    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementStartTagSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Name, this.Attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanToken, name, this.Attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes)
    {
        return this.Update(this.LessThanToken, this.Name, attributes, this.GreaterThanToken);
    }

    public XmlElementStartTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Name, this.Attributes, greaterThanToken);
    }

    public XmlElementStartTagSyntax AddAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.AddRange(items));
    }
  }

  public sealed partial class XmlElementEndTagSyntax : CSharpSyntaxNode
  {
    private XmlNameSyntax name;

    internal XmlElementEndTagSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LessThanSlashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlElementEndTagSyntax)this.Green).lessThanSlashToken, this.Position, 0); }
    }

    public XmlNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxToken GreaterThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlElementEndTagSyntax)this.Green).greaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementEndTag(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementEndTag(this);
    }

    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
        if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlElementEndTagSyntax WithLessThanSlashToken(SyntaxToken lessThanSlashToken)
    {
        return this.Update(lessThanSlashToken, this.Name, this.GreaterThanToken);
    }

    public XmlElementEndTagSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanSlashToken, name, this.GreaterThanToken);
    }

    public XmlElementEndTagSyntax WithGreaterThanToken(SyntaxToken greaterThanToken)
    {
        return this.Update(this.LessThanSlashToken, this.Name, greaterThanToken);
    }
  }

  public sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
  {
    private XmlNameSyntax name;
    private SyntaxNode attributes;

    internal XmlEmptyElementSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LessThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlEmptyElementSyntax)this.Green).lessThanToken, this.Position, 0); }
    }

    public XmlNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxList<XmlAttributeSyntax> Attributes 
    {
        get
        {
            return new SyntaxList<XmlAttributeSyntax>(this.GetRed(ref this.attributes, 2));
        }
    }

    public SyntaxToken SlashGreaterThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlEmptyElementSyntax)this.Green).slashGreaterThanToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            case 2: return this.GetRed(ref this.attributes, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            case 2: return this.attributes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlEmptyElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlEmptyElement(this);
    }

    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlEmptyElementSyntax WithLessThanToken(SyntaxToken lessThanToken)
    {
        return this.Update(lessThanToken, this.Name, this.Attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.LessThanToken, name, this.Attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithAttributes(SyntaxList<XmlAttributeSyntax> attributes)
    {
        return this.Update(this.LessThanToken, this.Name, attributes, this.SlashGreaterThanToken);
    }

    public XmlEmptyElementSyntax WithSlashGreaterThanToken(SyntaxToken slashGreaterThanToken)
    {
        return this.Update(this.LessThanToken, this.Name, this.Attributes, slashGreaterThanToken);
    }

    public XmlEmptyElementSyntax AddAttributes(params XmlAttributeSyntax[] items)
    {
        return this.WithAttributes(this.Attributes.AddRange(items));
    }
  }

  public sealed partial class XmlNameSyntax : CSharpSyntaxNode
  {
    private XmlPrefixSyntax prefix;

    internal XmlNameSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public XmlPrefixSyntax Prefix 
    {
        get
        {
            return this.GetRedAtZero(ref this.prefix);
        }
    }

    public SyntaxToken LocalName 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlNameSyntax)this.Green).localName, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.prefix);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlName(this);
    }

    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
        if (prefix != this.Prefix || localName != this.LocalName)
        {
            var newNode = SyntaxFactory.XmlName(prefix, localName);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlNameSyntax WithPrefix(XmlPrefixSyntax prefix)
    {
        return this.Update(prefix, this.LocalName);
    }

    public XmlNameSyntax WithLocalName(SyntaxToken localName)
    {
        return this.Update(this.Prefix, localName);
    }
  }

  public sealed partial class XmlPrefixSyntax : CSharpSyntaxNode
  {
    internal XmlPrefixSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken Prefix 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlPrefixSyntax)this.Green).prefix, this.Position, 0); }
    }

    public SyntaxToken ColonToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlPrefixSyntax)this.Green).colonToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlPrefix(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlPrefix(this);
    }

    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
    {
        if (prefix != this.Prefix || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlPrefixSyntax WithPrefix(SyntaxToken prefix)
    {
        return this.Update(prefix, this.ColonToken);
    }

    public XmlPrefixSyntax WithColonToken(SyntaxToken colonToken)
    {
        return this.Update(this.Prefix, colonToken);
    }
  }

  public abstract partial class XmlAttributeSyntax : CSharpSyntaxNode
  {
    internal XmlAttributeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract XmlNameSyntax Name { get; }
    public XmlAttributeSyntax WithName(XmlNameSyntax name) => WithNameCore(name);
    internal abstract XmlAttributeSyntax WithNameCore(XmlNameSyntax name);

    public abstract SyntaxToken EqualsToken { get; }
    public XmlAttributeSyntax WithEqualsToken(SyntaxToken equalsToken) => WithEqualsTokenCore(equalsToken);
    internal abstract XmlAttributeSyntax WithEqualsTokenCore(SyntaxToken equalsToken);

    public abstract SyntaxToken StartQuoteToken { get; }
    public XmlAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken) => WithStartQuoteTokenCore(startQuoteToken);
    internal abstract XmlAttributeSyntax WithStartQuoteTokenCore(SyntaxToken startQuoteToken);

    public abstract SyntaxToken EndQuoteToken { get; }
    public XmlAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken) => WithEndQuoteTokenCore(endQuoteToken);
    internal abstract XmlAttributeSyntax WithEndQuoteTokenCore(SyntaxToken endQuoteToken);
  }

  public sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
  {
    private XmlNameSyntax name;

    internal XmlTextAttributeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override XmlNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public override SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).equalsToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken StartQuoteToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).startQuoteToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(3);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxTokenList);
        }
    }

    public override SyntaxToken EndQuoteToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlTextAttributeSyntax)this.Green).endQuoteToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlTextAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlTextAttribute(this);
    }

    public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override XmlAttributeSyntax WithNameCore(XmlNameSyntax name) => WithName(name);
    public new XmlTextAttributeSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(name, this.EqualsToken, this.StartQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithEqualsTokenCore(SyntaxToken equalsToken) => WithEqualsToken(equalsToken);
    public new XmlTextAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken, this.StartQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithStartQuoteTokenCore(SyntaxToken startQuoteToken) => WithStartQuoteToken(startQuoteToken);
    public new XmlTextAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, startQuoteToken, this.TextTokens, this.EndQuoteToken);
    }

    public XmlTextAttributeSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, textTokens, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithEndQuoteTokenCore(SyntaxToken endQuoteToken) => WithEndQuoteToken(endQuoteToken);
    public new XmlTextAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.TextTokens, endQuoteToken);
    }

    public XmlTextAttributeSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
  {
    private XmlNameSyntax name;
    private CrefSyntax cref;

    internal XmlCrefAttributeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override XmlNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public override SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).equalsToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken StartQuoteToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).startQuoteToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public CrefSyntax Cref 
    {
        get
        {
            return this.GetRed(ref this.cref, 3);
        }
    }

    public override SyntaxToken EndQuoteToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlCrefAttributeSyntax)this.Green).endQuoteToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            case 3: return this.GetRed(ref this.cref, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 3: return this.cref;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCrefAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlCrefAttribute(this);
    }

    public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override XmlAttributeSyntax WithNameCore(XmlNameSyntax name) => WithName(name);
    public new XmlCrefAttributeSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(name, this.EqualsToken, this.StartQuoteToken, this.Cref, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithEqualsTokenCore(SyntaxToken equalsToken) => WithEqualsToken(equalsToken);
    public new XmlCrefAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken, this.StartQuoteToken, this.Cref, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithStartQuoteTokenCore(SyntaxToken startQuoteToken) => WithStartQuoteToken(startQuoteToken);
    public new XmlCrefAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, startQuoteToken, this.Cref, this.EndQuoteToken);
    }

    public XmlCrefAttributeSyntax WithCref(CrefSyntax cref)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, cref, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithEndQuoteTokenCore(SyntaxToken endQuoteToken) => WithEndQuoteToken(endQuoteToken);
    public new XmlCrefAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.Cref, endQuoteToken);
    }
  }

  public sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
  {
    private XmlNameSyntax name;
    private IdentifierNameSyntax identifier;

    internal XmlNameAttributeSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override XmlNameSyntax Name 
    {
        get
        {
            return this.GetRedAtZero(ref this.name);
        }
    }

    public override SyntaxToken EqualsToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).equalsToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken StartQuoteToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).startQuoteToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public IdentifierNameSyntax Identifier 
    {
        get
        {
            return this.GetRed(ref this.identifier, 3);
        }
    }

    public override SyntaxToken EndQuoteToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlNameAttributeSyntax)this.Green).endQuoteToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 0: return this.GetRedAtZero(ref this.name);
            case 3: return this.GetRed(ref this.identifier, 3);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 3: return this.identifier;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlNameAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlNameAttribute(this);
    }

    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override XmlAttributeSyntax WithNameCore(XmlNameSyntax name) => WithName(name);
    public new XmlNameAttributeSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(name, this.EqualsToken, this.StartQuoteToken, this.Identifier, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithEqualsTokenCore(SyntaxToken equalsToken) => WithEqualsToken(equalsToken);
    public new XmlNameAttributeSyntax WithEqualsToken(SyntaxToken equalsToken)
    {
        return this.Update(this.Name, equalsToken, this.StartQuoteToken, this.Identifier, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithStartQuoteTokenCore(SyntaxToken startQuoteToken) => WithStartQuoteToken(startQuoteToken);
    public new XmlNameAttributeSyntax WithStartQuoteToken(SyntaxToken startQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, startQuoteToken, this.Identifier, this.EndQuoteToken);
    }

    public XmlNameAttributeSyntax WithIdentifier(IdentifierNameSyntax identifier)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, identifier, this.EndQuoteToken);
    }

    internal override XmlAttributeSyntax WithEndQuoteTokenCore(SyntaxToken endQuoteToken) => WithEndQuoteToken(endQuoteToken);
    public new XmlNameAttributeSyntax WithEndQuoteToken(SyntaxToken endQuoteToken)
    {
        return this.Update(this.Name, this.EqualsToken, this.StartQuoteToken, this.Identifier, endQuoteToken);
    }
  }

  public sealed partial class XmlTextSyntax : XmlNodeSyntax
  {
    internal XmlTextSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(0);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.Position, 0);

            return default(SyntaxTokenList);
        }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlText(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlText(this);
    }

    public XmlTextSyntax Update(SyntaxTokenList textTokens)
    {
        if (textTokens != this.TextTokens)
        {
            var newNode = SyntaxFactory.XmlText(textTokens);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlTextSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(textTokens);
    }

    public XmlTextSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
  {
    internal XmlCDataSectionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken StartCDataToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlCDataSectionSyntax)this.Green).startCDataToken, this.Position, 0); }
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken EndCDataToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlCDataSectionSyntax)this.Green).endCDataToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCDataSection(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlCDataSection(this);
    }

    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)
    {
        if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
        {
            var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlCDataSectionSyntax WithStartCDataToken(SyntaxToken startCDataToken)
    {
        return this.Update(startCDataToken, this.TextTokens, this.EndCDataToken);
    }

    public XmlCDataSectionSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.StartCDataToken, textTokens, this.EndCDataToken);
    }

    public XmlCDataSectionSyntax WithEndCDataToken(SyntaxToken endCDataToken)
    {
        return this.Update(this.StartCDataToken, this.TextTokens, endCDataToken);
    }

    public XmlCDataSectionSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
  {
    private XmlNameSyntax name;

    internal XmlProcessingInstructionSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken StartProcessingInstructionToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlProcessingInstructionSyntax)this.Green).startProcessingInstructionToken, this.Position, 0); }
    }

    public XmlNameSyntax Name 
    {
        get
        {
            return this.GetRed(ref this.name, 1);
        }
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(2);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(2), this.GetChildIndex(2));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken EndProcessingInstructionToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlProcessingInstructionSyntax)this.Green).endProcessingInstructionToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 1: return this.GetRed(ref this.name, 1);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 1: return this.name;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlProcessingInstruction(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlProcessingInstruction(this);
    }

    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)
    {
        if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
        {
            var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlProcessingInstructionSyntax WithStartProcessingInstructionToken(SyntaxToken startProcessingInstructionToken)
    {
        return this.Update(startProcessingInstructionToken, this.Name, this.TextTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithName(XmlNameSyntax name)
    {
        return this.Update(this.StartProcessingInstructionToken, name, this.TextTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.StartProcessingInstructionToken, this.Name, textTokens, this.EndProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax WithEndProcessingInstructionToken(SyntaxToken endProcessingInstructionToken)
    {
        return this.Update(this.StartProcessingInstructionToken, this.Name, this.TextTokens, endProcessingInstructionToken);
    }

    public XmlProcessingInstructionSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public sealed partial class XmlCommentSyntax : XmlNodeSyntax
  {
    internal XmlCommentSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public SyntaxToken LessThanExclamationMinusMinusToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlCommentSyntax)this.Green).lessThanExclamationMinusMinusToken, this.Position, 0); }
    }

    public SyntaxTokenList TextTokens 
    {
        get
        {
            var slot = this.Green.GetSlot(1);
            if (slot != null)
                return new SyntaxTokenList(this, slot, this.GetChildPosition(1), this.GetChildIndex(1));

            return default(SyntaxTokenList);
        }
    }

    public SyntaxToken MinusMinusGreaterThanToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.XmlCommentSyntax)this.Green).minusMinusGreaterThanToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlComment(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlComment(this);
    }

    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
        if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    public XmlCommentSyntax WithLessThanExclamationMinusMinusToken(SyntaxToken lessThanExclamationMinusMinusToken)
    {
        return this.Update(lessThanExclamationMinusMinusToken, this.TextTokens, this.MinusMinusGreaterThanToken);
    }

    public XmlCommentSyntax WithTextTokens(SyntaxTokenList textTokens)
    {
        return this.Update(this.LessThanExclamationMinusMinusToken, textTokens, this.MinusMinusGreaterThanToken);
    }

    public XmlCommentSyntax WithMinusMinusGreaterThanToken(SyntaxToken minusMinusGreaterThanToken)
    {
        return this.Update(this.LessThanExclamationMinusMinusToken, this.TextTokens, minusMinusGreaterThanToken);
    }

    public XmlCommentSyntax AddTextTokens(params SyntaxToken[] items)
    {
        return this.WithTextTokens(this.TextTokens.AddRange(items));
    }
  }

  public abstract partial class DirectiveTriviaSyntax : StructuredTriviaSyntax
  {
    internal DirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract SyntaxToken HashToken { get; }
    public DirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) => WithHashTokenCore(hashToken);
    internal abstract DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken);

    public abstract SyntaxToken EndOfDirectiveToken { get; }
    public DirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveTokenCore(endOfDirectiveToken);
    internal abstract DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken);

    public abstract bool IsActive { get; }
  }

  public abstract partial class BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal BranchingDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract bool BranchTaken { get; }

    public new BranchingDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken) => (BranchingDirectiveTriviaSyntax)WithHashTokenCore(hashToken);
    public new BranchingDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken) => (BranchingDirectiveTriviaSyntax)WithEndOfDirectiveTokenCore(endOfDirectiveToken);
  }

  public abstract partial class ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal ConditionalDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
      : base(green, parent, position)
    {
    }

    public abstract ExpressionSyntax Condition { get; }
    public ConditionalDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition) => WithConditionCore(condition);
    internal abstract ConditionalDirectiveTriviaSyntax WithConditionCore(ExpressionSyntax condition);

    public abstract bool ConditionValue { get; }
  }

  public sealed partial class IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    private ExpressionSyntax condition;

    internal IfDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken IfKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).ifKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 2);
        }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).BranchTaken; } }

    public override bool ConditionValue { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.IfDirectiveTriviaSyntax)this.Green).ConditionValue; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfDirectiveTrivia(this);
    }

    public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.IfDirectiveTrivia(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new IfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithIfKeyword(SyntaxToken ifKeyword)
    {
        return this.Update(this.HashToken, ifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    internal override ConditionalDirectiveTriviaSyntax WithConditionCore(ExpressionSyntax condition) => WithCondition(condition);
    public new IfDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.HashToken, this.IfKeyword, condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new IfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, endOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, isActive, this.BranchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, branchTaken, this.ConditionValue);
    }

    public IfDirectiveTriviaSyntax WithConditionValue(bool conditionValue)
    {
        return this.Update(this.HashToken, this.IfKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, conditionValue);
    }
  }

  public sealed partial class ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    private ExpressionSyntax condition;

    internal ElifDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ElifKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).elifKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override ExpressionSyntax Condition 
    {
        get
        {
            return this.GetRed(ref this.condition, 2);
        }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).BranchTaken; } }

    public override bool ConditionValue { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElifDirectiveTriviaSyntax)this.Green).ConditionValue; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 2: return this.GetRed(ref this.condition, 2);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 2: return this.condition;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElifDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElifDirectiveTrivia(this);
    }

    public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElifDirectiveTrivia(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new ElifDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithElifKeyword(SyntaxToken elifKeyword)
    {
        return this.Update(this.HashToken, elifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    internal override ConditionalDirectiveTriviaSyntax WithConditionCore(ExpressionSyntax condition) => WithCondition(condition);
    public new ElifDirectiveTriviaSyntax WithCondition(ExpressionSyntax condition)
    {
        return this.Update(this.HashToken, this.ElifKeyword, condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new ElifDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, endOfDirectiveToken, this.IsActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, isActive, this.BranchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, branchTaken, this.ConditionValue);
    }

    public ElifDirectiveTriviaSyntax WithConditionValue(bool conditionValue)
    {
        return this.Update(this.HashToken, this.ElifKeyword, this.Condition, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken, conditionValue);
    }
  }

  public sealed partial class ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal ElseDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ElseKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).elseKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).IsActive; } }

    public override bool BranchTaken { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ElseDirectiveTriviaSyntax)this.Green).BranchTaken; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElseDirectiveTrivia(this);
    }

    public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
        if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElseDirectiveTrivia(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new ElseDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ElseKeyword, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    public ElseDirectiveTriviaSyntax WithElseKeyword(SyntaxToken elseKeyword)
    {
        return this.Update(this.HashToken, elseKeyword, this.EndOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new ElseDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ElseKeyword, endOfDirectiveToken, this.IsActive, this.BranchTaken);
    }

    public ElseDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ElseKeyword, this.EndOfDirectiveToken, isActive, this.BranchTaken);
    }

    public ElseDirectiveTriviaSyntax WithBranchTaken(bool branchTaken)
    {
        return this.Update(this.HashToken, this.ElseKeyword, this.EndOfDirectiveToken, this.IsActive, branchTaken);
    }
  }

  public sealed partial class EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal EndIfDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken EndIfKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax)this.Green).endIfKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EndIfDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndIfDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEndIfDirectiveTrivia(this);
    }

    public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndIfDirectiveTrivia(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new EndIfDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.EndIfKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndIfDirectiveTriviaSyntax WithEndIfKeyword(SyntaxToken endIfKeyword)
    {
        return this.Update(this.HashToken, endIfKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new EndIfDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.EndIfKeyword, endOfDirectiveToken, this.IsActive);
    }

    public EndIfDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.EndIfKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal RegionDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken RegionKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax)this.Green).regionKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.RegionDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRegionDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRegionDirectiveTrivia(this);
    }

    public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.RegionDirectiveTrivia(hashToken, regionKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new RegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.RegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public RegionDirectiveTriviaSyntax WithRegionKeyword(SyntaxToken regionKeyword)
    {
        return this.Update(this.HashToken, regionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new RegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.RegionKeyword, endOfDirectiveToken, this.IsActive);
    }

    public RegionDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.RegionKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal EndRegionDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken EndRegionKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax)this.Green).endRegionKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.EndRegionDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndRegionDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEndRegionDirectiveTrivia(this);
    }

    public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndRegionDirectiveTrivia(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new EndRegionDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.EndRegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public EndRegionDirectiveTriviaSyntax WithEndRegionKeyword(SyntaxToken endRegionKeyword)
    {
        return this.Update(this.HashToken, endRegionKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new EndRegionDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.EndRegionKeyword, endOfDirectiveToken, this.IsActive);
    }

    public EndRegionDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.EndRegionKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal ErrorDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ErrorKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax)this.Green).errorKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ErrorDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitErrorDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitErrorDirectiveTrivia(this);
    }

    public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ErrorDirectiveTrivia(hashToken, errorKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new ErrorDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ErrorKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public ErrorDirectiveTriviaSyntax WithErrorKeyword(SyntaxToken errorKeyword)
    {
        return this.Update(this.HashToken, errorKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new ErrorDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ErrorKeyword, endOfDirectiveToken, this.IsActive);
    }

    public ErrorDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ErrorKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal WarningDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken WarningKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax)this.Green).warningKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.WarningDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWarningDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWarningDirectiveTrivia(this);
    }

    public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.WarningDirectiveTrivia(hashToken, warningKeyword, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new WarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.WarningKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    public WarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword)
    {
        return this.Update(this.HashToken, warningKeyword, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new WarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.WarningKeyword, endOfDirectiveToken, this.IsActive);
    }

    public WarningDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.WarningKeyword, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal BadDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BadDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken Identifier 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BadDirectiveTriviaSyntax)this.Green).identifier, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BadDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.BadDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBadDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBadDirectiveTrivia(this);
    }

    public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.BadDirectiveTrivia(hashToken, identifier, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new BadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.Identifier, this.EndOfDirectiveToken, this.IsActive);
    }

    public BadDirectiveTriviaSyntax WithIdentifier(SyntaxToken identifier)
    {
        return this.Update(this.HashToken, identifier, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new BadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.Identifier, endOfDirectiveToken, this.IsActive);
    }

    public BadDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.Identifier, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal DefineDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken DefineKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).defineKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Name 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).name, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.DefineDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefineDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefineDirectiveTrivia(this);
    }

    public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.DefineDirectiveTrivia(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new DefineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.DefineKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveTriviaSyntax WithDefineKeyword(SyntaxToken defineKeyword)
    {
        return this.Update(this.HashToken, defineKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveTriviaSyntax WithName(SyntaxToken name)
    {
        return this.Update(this.HashToken, this.DefineKeyword, name, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new DefineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.DefineKeyword, this.Name, endOfDirectiveToken, this.IsActive);
    }

    public DefineDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.DefineKeyword, this.Name, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal UndefDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken UndefKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).undefKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Name 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).name, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.UndefDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUndefDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUndefDirectiveTrivia(this);
    }

    public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.UndefDirectiveTrivia(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new UndefDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.UndefKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveTriviaSyntax WithUndefKeyword(SyntaxToken undefKeyword)
    {
        return this.Update(this.HashToken, undefKeyword, this.Name, this.EndOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveTriviaSyntax WithName(SyntaxToken name)
    {
        return this.Update(this.HashToken, this.UndefKeyword, name, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new UndefDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.UndefKeyword, this.Name, endOfDirectiveToken, this.IsActive);
    }

    public UndefDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.UndefKeyword, this.Name, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class LineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal LineDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken LineKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).lineKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken Line 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).line, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken File 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).file;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(3), this.GetChildIndex(3));

            return default(SyntaxToken);
        }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LineDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLineDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLineDirectiveTrivia(this);
    }

    public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LineDirectiveTrivia(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new LineDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.LineKeyword, this.Line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithLineKeyword(SyntaxToken lineKeyword)
    {
        return this.Update(this.HashToken, lineKeyword, this.Line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithLine(SyntaxToken line)
    {
        return this.Update(this.HashToken, this.LineKeyword, line, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, file, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new LineDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, this.File, endOfDirectiveToken, this.IsActive);
    }

    public LineDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.LineKeyword, this.Line, this.File, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    private SyntaxNode errorCodes;

    internal PragmaWarningDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken PragmaKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).pragmaKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken WarningKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).warningKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken DisableOrRestoreKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).disableOrRestoreKeyword, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public SyntaxToken NullableKeyword 
    {
        get
        {
            var slot = ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).nullableKeyword;
            if (slot != null)
                return new SyntaxToken(this, slot, this.GetChildPosition(4), this.GetChildIndex(4));

            return default(SyntaxToken);
        }
    }

    public SeparatedSyntaxList<ExpressionSyntax> ErrorCodes 
    {
        get
        {
            var red = this.GetRed(ref this.errorCodes, 5);
            if (red != null)
                return new SeparatedSyntaxList<ExpressionSyntax>(red, this.GetChildIndex(5));

            return default(SeparatedSyntaxList<ExpressionSyntax>);
        }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaWarningDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            case 5: return this.GetRed(ref this.errorCodes, 5);
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            case 5: return this.errorCodes;
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaWarningDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPragmaWarningDirectiveTrivia(this);
    }

    public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SyntaxToken nullableKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || nullableKeyword != this.NullableKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaWarningDirectiveTrivia(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, nullableKeyword, errorCodes, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new PragmaWarningDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.NullableKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)
    {
        return this.Update(this.HashToken, pragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.NullableKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithWarningKeyword(SyntaxToken warningKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, warningKeyword, this.DisableOrRestoreKeyword, this.NullableKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithDisableOrRestoreKeyword(SyntaxToken disableOrRestoreKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, disableOrRestoreKeyword, this.NullableKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithNullableKeyword(SyntaxToken nullableKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, nullableKeyword, this.ErrorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithErrorCodes(SeparatedSyntaxList<ExpressionSyntax> errorCodes)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.NullableKeyword, errorCodes, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new PragmaWarningDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.NullableKeyword, this.ErrorCodes, endOfDirectiveToken, this.IsActive);
    }

    public PragmaWarningDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.WarningKeyword, this.DisableOrRestoreKeyword, this.NullableKeyword, this.ErrorCodes, this.EndOfDirectiveToken, isActive);
    }

    public PragmaWarningDirectiveTriviaSyntax AddErrorCodes(params ExpressionSyntax[] items)
    {
        return this.WithErrorCodes(this.ErrorCodes.AddRange(items));
    }
  }

  public sealed partial class PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal PragmaChecksumDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken PragmaKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).pragmaKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken ChecksumKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).checksumKeyword, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).file, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public SyntaxToken Guid 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).guid, this.GetChildPosition(4), this.GetChildIndex(4)); }
    }

    public SyntaxToken Bytes 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).bytes, this.GetChildPosition(5), this.GetChildIndex(5)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(6), this.GetChildIndex(6)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.PragmaChecksumDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaChecksumDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPragmaChecksumDirectiveTrivia(this);
    }

    public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaChecksumDirectiveTrivia(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new PragmaChecksumDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithPragmaKeyword(SyntaxToken pragmaKeyword)
    {
        return this.Update(this.HashToken, pragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithChecksumKeyword(SyntaxToken checksumKeyword)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, checksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, file, this.Guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithGuid(SyntaxToken guid)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, guid, this.Bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithBytes(SyntaxToken bytes)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, bytes, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new PragmaChecksumDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, endOfDirectiveToken, this.IsActive);
    }

    public PragmaChecksumDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.PragmaKeyword, this.ChecksumKeyword, this.File, this.Guid, this.Bytes, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal ReferenceDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ReferenceKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).referenceKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).file, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ReferenceDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReferenceDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitReferenceDirectiveTrivia(this);
    }

    public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ReferenceDirectiveTrivia(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new ReferenceDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ReferenceKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveTriviaSyntax WithReferenceKeyword(SyntaxToken referenceKeyword)
    {
        return this.Update(this.HashToken, referenceKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveTriviaSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, file, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new ReferenceDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, this.File, endOfDirectiveToken, this.IsActive);
    }

    public ReferenceDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ReferenceKeyword, this.File, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal LoadDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken LoadKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).loadKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken File 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).file, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.LoadDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLoadDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLoadDirectiveTrivia(this);
    }

    public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || loadKeyword != this.LoadKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LoadDirectiveTrivia(hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new LoadDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.LoadKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LoadDirectiveTriviaSyntax WithLoadKeyword(SyntaxToken loadKeyword)
    {
        return this.Update(this.HashToken, loadKeyword, this.File, this.EndOfDirectiveToken, this.IsActive);
    }

    public LoadDirectiveTriviaSyntax WithFile(SyntaxToken file)
    {
        return this.Update(this.HashToken, this.LoadKeyword, file, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new LoadDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.LoadKeyword, this.File, endOfDirectiveToken, this.IsActive);
    }

    public LoadDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.LoadKeyword, this.File, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal ShebangDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken ExclamationToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax)this.Green).exclamationToken, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.ShebangDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitShebangDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitShebangDirectiveTrivia(this);
    }

    public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || exclamationToken != this.ExclamationToken || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ShebangDirectiveTrivia(hashToken, exclamationToken, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new ShebangDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.ExclamationToken, this.EndOfDirectiveToken, this.IsActive);
    }

    public ShebangDirectiveTriviaSyntax WithExclamationToken(SyntaxToken exclamationToken)
    {
        return this.Update(this.HashToken, exclamationToken, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new ShebangDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.ExclamationToken, endOfDirectiveToken, this.IsActive);
    }

    public ShebangDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.ExclamationToken, this.EndOfDirectiveToken, isActive);
    }
  }

  public sealed partial class NullableDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal NullableDirectiveTriviaSyntax(StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.CSharpSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }

    public override SyntaxToken HashToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NullableDirectiveTriviaSyntax)this.Green).hashToken, this.Position, 0); }
    }

    public SyntaxToken NullableKeyword 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NullableDirectiveTriviaSyntax)this.Green).nullableKeyword, this.GetChildPosition(1), this.GetChildIndex(1)); }
    }

    public SyntaxToken SettingToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NullableDirectiveTriviaSyntax)this.Green).settingToken, this.GetChildPosition(2), this.GetChildIndex(2)); }
    }

    public override SyntaxToken EndOfDirectiveToken 
    {
      get { return new SyntaxToken(this, ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NullableDirectiveTriviaSyntax)this.Green).endOfDirectiveToken, this.GetChildPosition(3), this.GetChildIndex(3)); }
    }

    public override bool IsActive { get { return ((StarkPlatform.CodeAnalysis.Stark.Syntax.InternalSyntax.NullableDirectiveTriviaSyntax)this.Green).IsActive; } }

    internal override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }
    internal override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
            default: return null;
        }
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNullableDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNullableDirectiveTrivia(this);
    }

    public NullableDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || nullableKeyword != this.NullableKeyword || settingToken != this.SettingToken || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.NullableDirectiveTrivia(hashToken, nullableKeyword, settingToken, endOfDirectiveToken, isActive);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               return newNode.WithAnnotations(annotations);
            return newNode;
        }

        return this;
    }

    internal override DirectiveTriviaSyntax WithHashTokenCore(SyntaxToken hashToken) => WithHashToken(hashToken);
    public new NullableDirectiveTriviaSyntax WithHashToken(SyntaxToken hashToken)
    {
        return this.Update(hashToken, this.NullableKeyword, this.SettingToken, this.EndOfDirectiveToken, this.IsActive);
    }

    public NullableDirectiveTriviaSyntax WithNullableKeyword(SyntaxToken nullableKeyword)
    {
        return this.Update(this.HashToken, nullableKeyword, this.SettingToken, this.EndOfDirectiveToken, this.IsActive);
    }

    public NullableDirectiveTriviaSyntax WithSettingToken(SyntaxToken settingToken)
    {
        return this.Update(this.HashToken, this.NullableKeyword, settingToken, this.EndOfDirectiveToken, this.IsActive);
    }

    internal override DirectiveTriviaSyntax WithEndOfDirectiveTokenCore(SyntaxToken endOfDirectiveToken) => WithEndOfDirectiveToken(endOfDirectiveToken);
    public new NullableDirectiveTriviaSyntax WithEndOfDirectiveToken(SyntaxToken endOfDirectiveToken)
    {
        return this.Update(this.HashToken, this.NullableKeyword, this.SettingToken, endOfDirectiveToken, this.IsActive);
    }

    public NullableDirectiveTriviaSyntax WithIsActive(bool isActive)
    {
        return this.Update(this.HashToken, this.NullableKeyword, this.SettingToken, this.EndOfDirectiveToken, isActive);
    }
  }
}
